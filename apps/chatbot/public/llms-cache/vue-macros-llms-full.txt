---
url: /guide/eslint-integration.md
---
# <div i-logos:eslint inline-block /> ESLint Integration <PackageVersion name="@vue-macros/eslint-config" />

## Installation

::: code-group

```bash [pnpm]
pnpm add -D @vue-macros/eslint-config
```

```bash [yarn]
yarn add -D @vue-macros/eslint-config
```

```bash [npm]
npm i -D @vue-macros/eslint-config
```

:::

## Configuration

### Flat Configuration

```js [eslint.config.js]
import vueMacros from '@vue-macros/eslint-config/flat'
export default [
  vueMacros,
  // ...your other configurations
]
```

### Legacy Configuration

```jsonc [.eslintrc]
{
  "extends": [
    "@vue-macros/eslint-config",
    // ...your other configurations
  ],
}
```

---

---
url: /zh-CN/guide/eslint-integration.md
---
# <div i-logos:eslint inline-block /> ESLint 集成 <PackageVersion name="@vue-macros/eslint-config" />

## 安装

::: code-group

```bash [pnpm]
pnpm add -D @vue-macros/eslint-config
```

```bash [yarn]
yarn add -D @vue-macros/eslint-config
```

```bash [npm]
npm i -D @vue-macros/eslint-config
```

:::

## 配置

### Flat 风格配置

```js [eslint.config.js]
import vueMacros from '@vue-macros/eslint-config/flat'
export default [
  vueMacros,
  // ...其他配置
]
```

### 传统风格配置

```jsonc [.eslintrc]
{
  "extends": [
    "@vue-macros/eslint-config",
    // ...其他配置
  ],
}
```

---

---
url: /guide/nuxt-integration.md
---
# <div i-logos:nuxt-icon inline-block /> Nuxt Integration <PackageVersion name="@vue-macros/nuxt" />

### Installation

::: code-group

```bash [npm]
npm i -D @vue-macros/nuxt
```

```bash [yarn]
yarn add -D @vue-macros/nuxt
```

```bash [pnpm]
pnpm add -D @vue-macros/nuxt
```

:::

## Configuration

```ts [nuxt.config.ts]
export default {
  modules: [
    '@vue-macros/nuxt',
    // ...
  ],
  macros: {
    // overrides config options
  },
}
```

---

:tada: Congratulations! That's all.

To learn more about the macros, please visit [All Macros](/macros/) :laughing:.

---

---
url: /zh-CN/guide/nuxt-integration.md
---
# <div i-logos:nuxt-icon inline-block /> Nuxt 集成 <PackageVersion name="@vue-macros/nuxt" />

### 安装

::: code-group

```bash [npm]
npm i -D @vue-macros/nuxt
```

```bash [yarn]
yarn add -D @vue-macros/nuxt
```

```bash [pnpm]
pnpm add -D @vue-macros/nuxt
```

:::

## 配置

```ts [nuxt.config.ts]
export default {
  modules: [
    '@vue-macros/nuxt',
    // ...
  ],
  macros: {
    // 覆盖配置选项
  },
}
```

---

:tada: 恭喜你! 现在已经成功完成了对 Nuxt 的集成过程。

如果你还想要了解有关宏的更多信息, 请访问 [全部宏](/zh-CN/macros/) :laughing:。

---

---
url: /guide/astro-integration.md
---
# Astro Integration <PackageVersion name="@vue-macros/astro" />

### Installation

::: code-group

```bash [npm]
npm i -D @vue-macros/astro
```

```bash [yarn]
yarn add -D @vue-macros/astro
```

```bash [pnpm]
pnpm add -D @vue-macros/astro
```

:::

## Configuration

```ts [astro.config.mjs]
import Vue from '@astrojs/vue'
import Macros from '@vue-macros/astro'
import { defineConfig } from 'astro/config'

export default defineConfig({
  integrations: [
    Vue(),
    Macros({
      // overrides config options
    }),
  ],
})
```

## TypeScript Support & Volar Support

See the corresponding chapter on [Bundler Integration](./bundler-integration.md#typescript-support)

---

:tada: Congratulations! That's all.

To learn more about the macros, please visit [All Macros](/macros/) :laughing:.

---

---
url: /zh-CN/guide/astro-integration.md
---
# Astro 集成 <PackageVersion name="@vue-macros/astro" />

### 安装

::: code-group

```bash [npm]
npm i -D @vue-macros/astro
```

```bash [yarn]
yarn add -D @vue-macros/astro
```

```bash [pnpm]
pnpm add -D @vue-macros/astro
```

:::

## 配置

```ts [astro.config.mjs]
import Vue from '@astrojs/vue'
import Macros from '@vue-macros/astro'
import { defineConfig } from 'astro/config'

export default defineConfig({
  integrations: [
    Vue(),
    Macros({
      // 覆盖配置选项
    }),
  ],
})
```

## TypeScript 支持 和 Volar 支持

参见 [构建工具集成](./bundler-integration.md#typescript-support) 的对应章节。

---

:tada: 恭喜你! 现在已经成功完成了对 Astro 的集成过程。

如果你还想要了解有关宏的更多信息, 请访问 [全部宏](/zh-CN/macros/) :laughing:。

---

---
url: /features/better-define.md
---
# betterDefine <PackageVersion name="@vue-macros/better-define" />

<StabilityLevel level="stable" />

With enabling `betterDefine`, imported types are supported in `<script setup>` type-based-macros.

[Related issue](https://github.com/vuejs/core/issues/4294)

|  Features  |     Supported      |
| :--------: | :----------------: |
|   Vue 3    | :white_check_mark: |
|   Nuxt 3   | :white_check_mark: |
|   Vue 2    | :white_check_mark: |
| TypeScript | :white_check_mark: |

## Basic Usage

::: code-group

```vue twoslash [App.vue]
<script setup lang="ts">
// #region basic
type BaseProps = {
  title: string
}

export type { BaseProps }
// #endregion basic
// ---cut---
// @noErrors
import type { BaseProps } from './types'

interface Props extends BaseProps {
  foo: string
}
const props = defineProps<Props>()
</script>
```

<<< ./better-define.md#basic{ts} [types.ts]

:::

## ⚠️ Limitations

### Complex types

Complex types are not supported in some key places. For example:

#### What are Complex Types?

- All utility types
  - [Built-in types](https://www.typescriptlang.org/docs/handbook/utility-types.html)
  - All types from `type-fest` package.
  - `typeof` keyword.
  - ...
- Index Signature
  ```ts
  interface Type {
    [key: string]: string
  }
  ```
- Generics will be ignored directly

#### What are Key Places?

- The names of props.

```ts
// ✅
defineProps<{
  foo: ComplexType
}>()

// ❌
defineProps<{
  [ComplexType]: string
}>()
```

- The names of emits.

```ts
interface Emits {
  (event: 'something', value: ComplexType): void // ✅
  (event: ComplexType): void // ❌
}
```

---

---
url: /zh-CN/features/better-define.md
---
# betterDefine <PackageVersion name="@vue-macros/better-define" />

<StabilityLevel level="stable" />

通过开启 `betterDefine` ，支持在 `<script setup>` 中导入 TS 类型来定义 `props` 和 `emits`。

如果你对此功能有任何疑问，欢迎在 [issues](https://github.com/vuejs/core/issues/4294) 中发表评论。

|    特性    |        支持        |
| :--------: | :----------------: |
|   Vue 3    | :white_check_mark: |
|   Nuxt 3   | :white_check_mark: |
|   Vue 2    | :white_check_mark: |
| TypeScript | :white_check_mark: |

## 基本用法

::: code-group

```vue twoslash [App.vue]
<script setup lang="ts">
// #region basic
type BaseProps = {
  title: string
}

export type { BaseProps }
// #endregion basic
// ---cut---
// @noErrors
import type { BaseProps } from './types'

interface Props extends BaseProps {
  foo: string
}
const props = defineProps<Props>()
</script>
```

<<< ./better-define.md#basic{ts} [types.ts]

:::

## ⚠️ 限制

### 复杂类型

在一些**关键的位置**不支持**复杂类型**。例如：

#### 什么是复杂类型？

- 所有工具类型
  - [内置类型](https://www.typescriptlang.org/docs/handbook/utility-types.html)
  - 来自 `type-fest` 包的所有类型。
  - `typeof` 关键字.
  - ...
- 索引签名
  ```ts
  interface Type {
    [key: string]: string
  }
  ```
- 泛型将会被直接忽略

#### 什么是**关键的位置**?

- **props** 的名称

```ts
// ✅
defineProps<{
  foo: ComplexType
}>()

// ❌
defineProps<{
  [ComplexType]: string
}>()
```

- **emits** 的名称

```ts
interface Emits {
  (event: 'something', value: ComplexType): void // ✅
  (event: ComplexType): void // ❌
}
```

---

---
url: /features/boolean-prop.md
---
# booleanProp <PackageVersion name="@vue-macros/boolean-prop" />

<StabilityLevel level="experimental" />

Convert `<Comp checked />` to `<Comp :checked="true" />`.

Convert `<Comp !checked />` to `<Comp :checked="false" />`.

|   Features   |     Supported      |
| :----------: | :----------------: |
|    Vue 3     | :white_check_mark: |
|    Nuxt 3    | :white_check_mark: |
|    Vue 2     |        :x:         |
| Volar Plugin | :white_check_mark: |

## Options

```ts
interface Options {
  /**
   * @default '!'
   */
  negativePrefix?: string
}
```

## Usage

<!-- prettier-ignore-start -->
```vue twoslash
<script setup>
import type { FunctionalComponent } from 'vue'

export const Comp: FunctionalComponent<
  {
    checked: true,
    enabled: false,
  },
> = () => null
// ---cut---
// @noErrors
import Comp from './Comp.vue'
</script>

<template>
  <Comp checked !enabled />
  //             ^?
</template>
```
<!-- prettier-ignore-end -->

```vue twoslash
<script setup lang="ts">
// Comp.vue
defineProps<{
  checked: true
  enabled: false
}>()
</script>
```

## Volar Configuration

```jsonc {3,5} [tsconfig.json]
{
  "vueCompilerOptions": {
    "plugins": ["vue-macros/volar"],
    "vueMacros": {
      "booleanProp": true,
    },
  },
}
```

---

---
url: /zh-CN/features/boolean-prop.md
---
# booleanProp <PackageVersion name="@vue-macros/boolean-prop" />

<StabilityLevel level="experimental" />

把 `<Comp checked />` 转换为 `<Comp :checked="true" />`。

把 `<Comp !checked />` 转换为 `<Comp :checked="false" />`。

|   Features   |     Supported      |
| :----------: | :----------------: |
|    Vue 3     | :white_check_mark: |
|    Nuxt 3    | :white_check_mark: |
|    Vue 2     |        :x:         |
| Volar Plugin | :white_check_mark: |

## 选项

```ts
interface Options {
  /**
   * @default '!'
   */
  negativePrefix?: string
}
```

## 基本用法

<!-- prettier-ignore-start -->
```vue twoslash
<script setup>
import type { FunctionalComponent } from 'vue'

export const Comp: FunctionalComponent<
  {
    checked: true,
    enabled: false,
  },
> = () => null
// ---cut---
// @noErrors
import Comp from './Comp.vue'
</script>

<template>
  <Comp checked !enabled />
  //             ^?
</template>
```
<!-- prettier-ignore-end -->

```vue twoslash
<script setup lang="ts">
// Comp.vue
defineProps<{
  checked: true
  enabled: false
}>()
</script>
```

## Volar 配置

```jsonc {3,5} [tsconfig.json]
{
  "vueCompilerOptions": {
    "plugins": ["vue-macros/volar"],
    "vueMacros": {
      "booleanProp": true,
    },
  },
}
```

---

---
url: /guide/bundler-integration.md
---
# Bundler Integration <PackageVersion name="vue-macros" />

## Installation

::: tip

Vite and Rollup are fully supported, while other bundlers have limited support.

:::

::: code-group

```bash [npm]
npm i -D vue-macros
```

```bash [yarn]
yarn add -D vue-macros
```

```bash [pnpm]
pnpm add -D vue-macros
```

:::

::: code-group

```ts [Vite]
// vite.config.ts
import Vue from '@vitejs/plugin-vue'
import VueMacros from 'vue-macros/vite'
// import VueJsx from '@vitejs/plugin-vue-jsx'
// import VueRouter from 'unplugin-vue-router/vite'

export default defineConfig({
  plugins: [
    VueMacros({
      plugins: {
        vue: Vue(),
        // vueJsx: VueJsx(), // if needed
        // vueRouter: VueRouter({ // if needed
        //   extensions: ['.vue', '.setup.tsx']
        // })
      },
      // overrides plugin options
    }),
  ],
})
```

```ts [Rollup]
// rollup.config.js (Requires Rollup 3+)
import Vue from 'unplugin-vue/rollup'
import VueMacros from 'vue-macros/rollup'
// import VueRouter from 'unplugin-vue-router/rollup'

export default {
  plugins: [
    VueMacros({
      plugins: {
        vue: Vue(),
        // vueJsx: VueJsx(), // if needed
        // vueRouter: VueRouter({ // if needed
        //   extensions: ['.vue', '.setup.tsx']
        // })
      },
      // overrides plugin options
    }),
  ],
}
```

```js [esbuild]
// esbuild.config.js
import { build } from 'esbuild'
// import VueRouter from 'unplugin-vue-router/esbuild'

build({
  plugins: [
    require('vue-macros/esbuild')({
      plugins: {
        vue: require('unplugin-vue/esbuild')(),
        // vueJsx: VueJsx(), // if needed
        // vueRouter: VueRouter({ // if needed
        //   extensions: ['.vue', '.setup.tsx']
        // })
      },
      // overrides plugin options
    }),
  ],
})
```

```js [Webpack]
// webpack.config.js (Requires Webpack 5+)
module.exports = {
  /* ... */
  plugins: [
    require('vue-macros/webpack')({
      // overrides plugin options
    }),
  ],
}
```

```js [Rspack]
// rspack.config.js
module.exports = {
  /* ... */
  plugins: [
    require('vue-macros/rspack')({
      // overrides plugin options
    }),
  ],
}
```

```js [Rsbuild]
// rsbuild.config.js
module.exports = {
  // ...
  tools: {
    rspack: {
      plugins: [
        require('vue-macros/rspack')({
          // overrides plugin options
        }),
      ],
    },
  },
}
```

```js [Vue CLI]
// vue.config.js (Requires Vue CLI 5+)
const { defineConfig } = require('@vue/cli-service')
const VueMacros = require('vue-macros/webpack')

module.exports = defineConfig({
  // ...
  // ⚠️ IMPORTANT
  parallel: false,
  configureWebpack: {
    plugins: [
      VueMacros({
        // overrides plugin options
      }),
    ],
  },
})
```

:::

## Configuration

See the [Configurations](./configurations.md) for more details.

```ts twoslash [vue-macros.config.ts]
import { defineConfig } from 'vue-macros'
export default defineConfig({
  // options
})
```

## TypeScript Support

```json {0}
// tsconfig.json
{
  "compilerOptions": {
    // ...
    "types": ["vue-macros/macros-global" /* ... */]
  }
}
```

## Volar Support

For detailed configuration, please refer to the description of the specific macro.

```jsonc [tsconfig.json]
{
  "vueCompilerOptions": {
    "plugins": ["vue-macros/volar"],
  },
}
```

### Scoped Plugins

`exportExpose`, `exportProps`, and `exportRender` plugins cannot be used
at the same time unless providing a scope.

```ts twoslash [vue-macros.config.ts]
import { defineConfig } from 'vue-macros'
export default defineConfig({
  exportExpose: {
    include: ['**/export-expose/**'],
  },
  exportProps: {
    include: ['**/export-props/**'],
  },
  exportRender: {
    include: ['**/export-render/**'],
  },
})
```

---

:tada: Congratulations! You have successfully set up Vue Macros.

To learn more about the macros, please visit [All Macros](/macros/) :laughing:.

---

---
url: /macros/chain-call.md
---
# chainCall <PackageVersion name="@vue-macros/chain-call" />

<StabilityLevel level="experimental" />

Extends `defineProps`, support call `withDefaults` as a chain.

|   Features   |     Supported      |
| :----------: | :----------------: |
|    Vue 3     | :white_check_mark: |
|    Nuxt 3    |     :question:     |
|    Vue 2     |     :question:     |
|  TypeScript  | :white_check_mark: |
| Volar Plugin |        :x:         |

::: tip

- `chainCall` does not support `definePropsRefs`
- To fully support TypeScript, you need to import this macro from `vue-macros/macros`.

:::

## Basic Usage

```vue
<script setup lang="ts">
const props = defineProps<{
  foo?: string
  bar?: number[]
  baz?: boolean
}>().withDefaults({
  foo: '111',
  bar: () => [1, 2, 3],
})
</script>
```

::: details Compiled Code

```vue twoslash
<script setup lang="ts">
const props = withDefaults(
  defineProps<{
    foo?: string
    bar?: number[]
    baz?: boolean
  }>(),
  {
    foo: '111',
    bar: () => [1, 2, 3],
  },
)
</script>
```

:::

Also support [props destructuring](../features/reactivity-transform.md) and JSX:

```vue
<script setup lang="ts">
const { foo } = defineProps<{ foo: string }>().withDefaults({
  foo: '111',
})
</script>
```

## TypeScript

To fully support TypeScript, you need to import this macro from `vue-macros/macros` with specific syntax.

```vue twoslash
<script setup lang="ts">
import { defineProps } from 'vue-macros/macros' with { type: 'macro' }

defineProps<{
  /* ... */
}>().withDefaults({
  /* ... */
})
// ✅ type safe
</script>
```

Works without import assertion, but tsc will report an error:

```ts twoslash
// @errors: 2339
defineProps<{
  /* ... */
}>().withDefaults({
  /* ... */
})
```

---

---
url: /zh-CN/macros/chain-call.md
---
# chainCall <PackageVersion name="@vue-macros/chain-call" />

<StabilityLevel level="experimental" />

扩展 `defineProps`，支持链式调用 `withDefaults`。

|   Features   |     Supported      |
| :----------: | :----------------: |
|    Vue 3     | :white_check_mark: |
|    Nuxt 3    |     :question:     |
|    Vue 2     |     :question:     |
|  TypeScript  | :white_check_mark: |
| Volar Plugin |        :x:         |

::: tip

- `chainCall` 不支持 `definePropsRefs`。
- 你需要从 `vue-macros/macros` 中导入此宏以获取更好的类型检查。

:::

## 基本用法

```vue
<script setup lang="ts">
const props = defineProps<{
  foo?: string
  bar?: number[]
  baz?: boolean
}>().withDefaults({
  foo: '111',
  bar: () => [1, 2, 3],
})
</script>
```

::: details 编译后的代码

```vue twoslash
<script setup lang="ts">
const props = withDefaults(
  defineProps<{
    foo?: string
    bar?: number[]
    baz?: boolean
  }>(),
  {
    foo: '111',
    bar: () => [1, 2, 3],
  },
)
</script>
```

:::

也支持 [props 解构](../features/reactivity-transform.md) 和 JSX：

```vue
<script setup lang="ts">
const { foo } = defineProps<{ foo: string }>().withDefaults({
  foo: '111',
})
</script>
```

## TypeScript

为了更好的类型支持，你需要使用特定的语法从 `vue-macros/macros` 中导入此宏。

```vue twoslash
<script setup lang="ts">
import { defineProps } from 'vue-macros/macros' with { type: 'macro' }

defineProps<{
  /* ... */
}>().withDefaults({
  /* ... */
})
// ✅ 类型安全
</script>
```

没有 `import` 也可以正常使用，但 `tsc` 会报告一个类型错误：

```ts twoslash
// @errors: 2339
defineProps<{
  /* ... */
}>().withDefaults({
  /* ... */
})
```

---

---
url: /guide/configurations.md
---
# Configurations

## Plugin Options

All features are enabled by default except the following.

#### Disabled by Default

- `exportExpose`
- `exportProps`
- `exportRender`
- `setupSFC`
- `booleanProp`
- `shortBind`
- `defineStyleX`

#### Disabled by Default when Vue >= 3.3

- `defineOptions`
- `defineSlots`
- `hoistStatic`
- `shortEmits`

You can re-enable them by setting the option to `true`.

```ts twoslash [vue-macros.config.(ts,js,json)]
import { defineConfig } from 'vue-macros'
export default defineConfig({
  root: '/your-project-path',

  /**
   * Vue version, 2 or 3.
   *
   * optional, detecting automatically.
   */
  version: 3,

  /** Defaults to true */
  defineModels: {
    // ...
  },

  // Enable features
  defineOptions: true,

  // Disable features
  hoistStatic: false,

  // ... more features
})
```

Refer to the macros and features page for available options.

---

---
url: /macros/define-emit.md
---
# defineEmit <PackageVersion name="@vue-macros/define-emit" />

<StabilityLevel level="experimental" />

Declare single emit one by one using `defineEmit`.

|   Features   |     Supported      |
| :----------: | :----------------: |
|    Vue 3     | :white_check_mark: |
|    Nuxt 3    | :white_check_mark: |
|    Vue 2     | :white_check_mark: |
|  TypeScript  | :white_check_mark: |
| Volar Plugin | :white_check_mark: |

::: warning

`defineEmit` can not be used with `defineEmits` at same time

:::

## API Reference

```ts
defineEmit<T>(emitName)
defineEmit<T>(emitName, validator)

// emitName parameter can be optional,
// and will be inferred from variable name
const emitName = defineEmit<T>()
```

## Basic Usage

```vue twoslash
<script setup>
// Declare emit
const increment = defineEmit('increment')
// Infer emit name from variable name
const change = defineEmit()
// emit event
increment()
</script>
```

## With Validation

```vue twoslash
<script setup>
// Declare event with validation
const increment = defineEmit('increment', (value) => value < 20)
</script>
```

## TypeScript

```vue twoslash
<script setup lang="ts">
const increment = defineEmit('increment', (value: number) => value < 20)
const decrement = defineEmit<[value: number]>()

increment(2) // pass
// @errors: 2345
increment('2') // TS type error
</script>
```

## Volar Configuration

```jsonc {3,5} [tsconfig.json]
{
  "vueCompilerOptions": {
    "plugins": ["vue-macros/volar"],
    "vueMacros": {
      "defineEmit": true,
    },
  },
}
```

---

---
url: /zh-CN/macros/define-emit.md
---
# defineEmit <PackageVersion name="@vue-macros/define-emit" />

<StabilityLevel level="experimental" />

使用 `defineEmit` 逐个声明单个 emit。

|     特性     |        支持        |
| :----------: | :----------------: |
|    Vue 3     | :white_check_mark: |
|    Nuxt 3    | :white_check_mark: |
|    Vue 2     | :white_check_mark: |
|  TypeScript  | :white_check_mark: |
| Volar Plugin | :white_check_mark: |

::: warning

`defineEmit` 不能与 `defineEmits` 同时使用。

:::

## API 参考

```ts
defineEmit<T>(emitName)
defineEmit<T>(emitName, validator)

// emitName 参数是可选的，
// 并且可从变量名中推断出
const emitName = defineEmit<T>()
```

## 基本用法

```vue twoslash
<script setup>
// 声明 emit
const increment = defineEmit('increment')
// 从变量名中推断出 emit 名称
const change = defineEmit()
// emit 事件
increment()
</script>
```

## 带验证的用法

```vue twoslash
<script setup>
// 声明带验证的事件
const increment = defineEmit('increment', (value) => value < 20)
</script>
```

## TypeScript

```vue twoslash
<script setup lang="ts">
const increment = defineEmit('increment', (value: number) => value < 20)
const decrement = defineEmit<[value: number]>()

increment(2) // pass
// @errors: 2345
increment('2') // TS type error
</script>
```

## Volar 配置

```jsonc {3,5} [tsconfig.json]
{
  "vueCompilerOptions": {
    "plugins": ["vue-macros/volar"],
    "vueMacros": {
      "defineEmit": true,
    },
  },
}
```

---

---
url: /volar/define-generic.md
---
# defineGeneric <PackageVersion name="@vue-macros/volar" />

<StabilityLevel level="stable" />

Declare single generic one by one using `DefineGeneric`.

> Especially useful for `setup-sfc`.

|   Features   |     Supported      |
| :----------: | :----------------: |
| Volar Plugin | :white_check_mark: |

## Basic Usage

::: code-group

```vue [App.vue] twoslash
<script setup lang="ts">
// @errors: 2322
defineOptions({
  name: 'App',
})

type T = DefineGeneric<number>

defineProps<{
  foo: T
}>()
</script>

<template>
  <App foo="1" />
</template>
```

:::

## Volar Configuration

```jsonc {3} [tsconfig.json]
{
  "vueCompilerOptions": {
    "plugins": ["vue-macros/volar"],
  },
}
```

---

---
url: /zh-CN/volar/define-generic.md
---
# defineGeneric <PackageVersion name="@vue-macros/volar" />

<StabilityLevel level="stable" />

使用 `DefineGeneric` 逐个声明单个范型。

> 对于 `setup-sfc` 特别有用。

|   Features   |     Supported      |
| :----------: | :----------------: |
| Volar Plugin | :white_check_mark: |

## 基本用法

::: code-group

```vue [App.vue] twoslash
<script setup lang="ts">
// @errors: 2322
defineOptions({
  name: 'App',
})

type T = DefineGeneric<number>

defineProps<{
  foo: T
}>()
</script>

<template>
  <App foo="1" />
</template>
```

:::

## Volar 配置

```jsonc {3} [tsconfig.json]
{
  "vueCompilerOptions": {
    "plugins": ["vue-macros/volar"],
  },
}
```

---

---
url: /macros/define-models.md
---
# defineModels <PackageVersion name="@vue-macros/define-models" />

<StabilityLevel level="stable" />

Declaring and mutate `v-model` props as the same as normal variable using the `defineModels`.

|   Features   |     Supported      |
| :----------: | :----------------: |
|    Vue 3     | :white_check_mark: |
|    Nuxt 3    | :white_check_mark: |
|    Vue 2     | :white_check_mark: |
| Volar Plugin | :white_check_mark: |

## Options

```ts
VueMacros({
  defineModels: {
    /**
     * Unified mode, only works for Vue 2
     *
     * Converts `modelValue` to `value`
     */
    unified: false,
  },
})
```

## Basic Usage

Requires [`@vueuse/core`](https://www.npmjs.com/package/@vueuse/core), install it by yourself before using.

```vue twoslash
<script setup lang="ts">
const { modelValue, count } = defineModels<{
  modelValue: string
  count: number
}>()

console.log(modelValue.value)
modelValue.value = 'newValue'
</script>
```

::: warning ❌ Object declaring is not supported.

```vue
<script setup lang="ts">
const { modelValue } = defineModels({
  modelValue: String,
})
</script>
```

:::

## With Model Options

```vue twoslash 3-6
<script setup lang="ts">
const { modelValue } = defineModels<{
  modelValue: ModelOptions<
    string,
    { defaultValue: 'something'; deep: true; passive: true }
  >
}>()
</script>
```

## With Reactivity Transform

::: warning

Assignment expression is only supported in `<script setup>` block. In other words invalid in `<template>`.

:::

[`@vueuse/core`](https://www.npmjs.com/package/@vueuse/core) is not required.

```vue twoslash {7-9}
<script setup lang="ts">
let { modelValue, count } = $defineModels<{
  modelValue: string
  count: number
}>()

console.log(modelValue)
modelValue = 'newValue'
count++
</script>
```

::: details Compiled Code

```vue twoslash
<script setup lang="ts">
const { modelValue, count } = defineProps<{
  modelValue: string
  count: number
}>()

const emit = defineEmits<{
  (evt: 'update:modelValue', value: string): void
  (evt: 'update:count', value: number): void
}>()

console.log(modelValue)
emit('update:modelValue', 'newValue')
emit('update:count', count + 1)
</script>
```

:::

## Volar Configuration

```jsonc {4,6-9} [tsconfig.json]
{
  "vueCompilerOptions": {
    "target": 3, // or 2.7 for Vue 2
    "plugins": ["vue-macros/volar"],
    "vueMacros": {
      "defineModels": {
        // Only works when target is 2.7.
        "unified": true,
      },
    },
  },
}
```

---

---
url: /zh-CN/macros/define-models.md
---
# defineModels <PackageVersion name="@vue-macros/define-models" />

<StabilityLevel level="stable" />

使用 `defineModels` 可以简化声明和修改 `v-model` 值的步骤，就像是在使用一个普通变量一样。

|     特性     |        支持        |
| :----------: | :----------------: |
|    Vue 3     | :white_check_mark: |
|    Nuxt 3    | :white_check_mark: |
|    Vue 2     | :white_check_mark: |
| Volar Plugin | :white_check_mark: |

## 选项

```ts
VueMacros({
  defineModels: {
    /**
     * Unified 模式，仅在 Vue 2 下有效
     *
     * 将 `modelValue` 转换为 `value`
     */
    unified: false,
  },
})
```

## 基本用法

在开始之前，请先自行安装 [`@vueuse/core`](https://www.npmjs.com/package/@vueuse/core)

```vue twoslash
<script setup lang="ts">
const { modelValue, count } = defineModels<{
  modelValue: string
  count: number
}>()

console.log(modelValue.value)
modelValue.value = 'newValue'
</script>
```

::: warning ❌ 不支持对象声明

```vue
<script setup lang="ts">
const { modelValue } = defineModels({
  modelValue: String,
})
</script>
```

:::

## model 选项

```vue twoslash 3-6
<script setup lang="ts">
const { modelValue } = defineModels<{
  modelValue: ModelOptions<
    string,
    { defaultValue: 'something'; deep: true; passive: true }
  >
}>()
</script>
```

## 响应性语法糖

::: warning

赋值表达式 仅在 `<script setup>` 块中受支持。换句话说，在 `<template>`中无效。

:::

[`@vueuse/core`](https://www.npmjs.com/package/@vueuse/core) 在这不是必需的。

```vue twoslash {7-9}
<script setup lang="ts">
let { modelValue, count } = $defineModels<{
  modelValue: string
  count: number
}>()

console.log(modelValue)
modelValue = 'newValue'
count++
</script>
```

::: details 编译后的代码

```vue twoslash
<script setup lang="ts">
const { modelValue, count } = defineProps<{
  modelValue: string
  count: number
}>()

const emit = defineEmits<{
  (evt: 'update:modelValue', value: string): void
  (evt: 'update:count', value: number): void
}>()

console.log(modelValue)
emit('update:modelValue', 'newValue')
emit('update:count', count + 1)
</script>
```

:::

## Volar 配置

```jsonc {4,6-9} [tsconfig.json]
{
  "vueCompilerOptions": {
    "target": 3, // 或 2.7 用于 Vue 2
    "plugins": ["vue-macros/volar"],
    "vueMacros": {
      "defineModels": {
        // 仅在 target 是 2.7 时有效
        "unified": true,
      },
    },
  },
}
```

---

---
url: /macros/define-options.md
---
# defineOptions <PackageVersion name="unplugin-vue-define-options" />

<StabilityLevel level="stable" />

Options API can be declared using the `defineOptions` in `<script setup>`, specifically to be able to set `name`, `props`, `emits`, and `render` inside of one function.

For Vue >= 3.3, this feature will be turned off by default.

|  Features  |     Supported      |
| :--------: | :----------------: |
|   Vue 3    | :white_check_mark: |
|   Nuxt 3   | :white_check_mark: |
|   Vue 2    | :white_check_mark: |
| TypeScript | :white_check_mark: |

## Installation Standalone Version

if you need `defineOptions` feature only, the standalone version is more appropriate for you.

### Installation

::: code-group

```bash [npm]
npm i -D unplugin-vue-define-options @vue-macros/volar
```

```bash [yarn]
yarn add -D unplugin-vue-define-options @vue-macros/volar
```

```bash [pnpm]
pnpm add -D unplugin-vue-define-options @vue-macros/volar
```

:::

::: code-group

```ts [Vite]
// vite.config.ts
import DefineOptions from 'unplugin-vue-define-options/vite'

export default defineConfig({
  plugins: [DefineOptions()],
})
```

```ts [Rollup]
// rollup.config.js
import DefineOptions from 'unplugin-vue-define-options/rollup'

export default {
  plugins: [DefineOptions()],
}
```

```js [esbuild]
// esbuild.config.js
import { build } from 'esbuild'

build({
  plugins: [require('unplugin-vue-define-options/esbuild')()],
})
```

```js [Webpack]
// webpack.config.js
module.exports = {
  /* ... */
  plugins: [require('unplugin-vue-define-options/webpack')()],
}
```

:::

### TypeScript Support

```json [tsconfig.json]
{
  "compilerOptions": {
    // ...
    "types": ["unplugin-vue-define-options/macros-global" /* ... */]
  }
}
```

## Basic Usage

```vue twoslash {3-4}
<script setup lang="ts">
defineOptions({
  name: 'Foo',
  inheritAttrs: false,
})

defineProps<{
  foo: number
}>()
</script>

<template>
  <Foo :foo="1" />
</template>
```

::: details Compiled Code

```vue twoslash
<script lang="ts">
export default {
  name: 'Foo',
  inheritAttrs: false,
}
</script>

<script setup lang="ts">
defineProps<{
  foo: number
}>()
</script>

<template>
  <Foo :foo="1" />
</template>
```

:::

## JSX in `<script setup>`

```vue twoslash {3-5}
<script setup lang="tsx">
defineOptions({
  render() {
    return <h1>Hello World</h1>
  },
})
</script>
```

::: details Compiled Code

```vue
<script lang="tsx">
export default {
  render() {
    return <h1>Hello World</h1>
  },
}
</script>
```

:::

## Volar Configuration

```jsonc {3} [tsconfig.json]
{
  "vueCompilerOptions": {
    "plugins": ["vue-macros/volar"],
  },
}
```

---

---
url: /zh-CN/macros/define-options.md
---
# defineOptions <PackageVersion name="unplugin-vue-define-options" />

<StabilityLevel level="stable" />

可以通过 `defineOptions` 宏在 `<script setup>` 中使用选项式 API，也就是说可以在一个宏函数中设置 `name`, `props`, `emits`, `render`。

在 Vue >= 3.3 中，此功能将默认关闭。

|    特性    |        支持        |
| :--------: | :----------------: |
|   Vue 3    | :white_check_mark: |
|   Nuxt 3   | :white_check_mark: |
|   Vue 2    | :white_check_mark: |
| TypeScript | :white_check_mark: |

## 安装独立版本

如果你只需要 `defineOptions` 功能, 那么独立版本更适合你。

### 安装

::: code-group

```bash [npm]
npm i -D unplugin-vue-define-options @vue-macros/volar
```

```bash [yarn]
yarn add -D unplugin-vue-define-options @vue-macros/volar
```

```bash [pnpm]
pnpm add -D unplugin-vue-define-options @vue-macros/volar
```

:::

::: code-group

```ts [Vite]
// vite.config.ts
import DefineOptions from 'unplugin-vue-define-options/vite'

export default defineConfig({
  plugins: [DefineOptions()],
})
```

```ts [Rollup]
// rollup.config.js
import DefineOptions from 'unplugin-vue-define-options/rollup'

export default {
  plugins: [DefineOptions()],
}
```

```js [esbuild]
// esbuild.config.js
import { build } from 'esbuild'

build({
  plugins: [require('unplugin-vue-define-options/esbuild')()],
})
```

```js [Webpack]
// webpack.config.js
module.exports = {
  /* ... */
  plugins: [require('unplugin-vue-define-options/webpack')()],
}
```

:::

### TypeScript 支持

```json [tsconfig.json]
{
  "compilerOptions": {
    // ...
    "types": ["unplugin-vue-define-options/macros-global" /* ... */]
  }
}
```

## 基本用法

```vue twoslash {3-4}
<script setup lang="ts">
defineOptions({
  name: 'Foo',
  inheritAttrs: false,
})

defineProps<{
  foo: number
}>()
</script>

<template>
  <Foo :foo="1" />
</template>
```

::: details 编译后的代码

```vue twoslash
<script lang="ts">
export default {
  name: 'Foo',
  inheritAttrs: false,
}
</script>

<script setup lang="ts">
defineProps<{
  foo: number
}>()
</script>

<template>
  <Foo :foo="1" />
</template>
```

:::

## `<script setup>` 中使用 JSX

```vue twoslash {3-5}
<script setup lang="tsx">
defineOptions({
  render() {
    return <h1>Hello World</h1>
  },
})
</script>
```

::: details 编译后的代码

```vue
<script lang="tsx">
export default {
  render() {
    return <h1>Hello World</h1>
  },
}
</script>
```

:::

## Volar 配置

```jsonc {3} [tsconfig.json]
{
  "vueCompilerOptions": {
    "plugins": ["vue-macros/volar"],
  },
}
```

---

---
url: /macros/define-prop.md
---
# defineProp <PackageVersion name="@vue-macros/define-prop" />

<StabilityLevel level="experimental" />

Declare single prop one by one using `defineProp`.

|      Features      |     Supported      |
| :----------------: | :----------------: |
|       Vue 3        | :white_check_mark: |
|       Nuxt 3       | :white_check_mark: |
|       Vue 2        | :white_check_mark: |
| TypeScript / Volar | :white_check_mark: |

::: warning

`defineProp` can not be used in the same file as type-declared `defineProps`.

:::

## Configuration

```ts
VueMacros({
  defineProp: {
    /**
     * 'kevinEdition' | 'johnsonEdition'
     * @default 'kevinEdition'
     */
    edition: 'kevinEdition',
  },
})
```

## Kevin's Edition (Default)

### API Reference

```ts
defineProp<T>(propName)
defineProp<T>(propName, options)

// propName parameter can be optional,
// and will be inferred from variable name
const propName = defineProp<T>()
```

### Basic Usage

```vue twoslash
<!-- @experimentalDefinePropProposal "kevinEdition" -->

<script setup lang="ts">
// Declare prop
const count = defineProp('count')

// Infer prop name from variable name
const value = defineProp()

// access prop value
console.log(count.value)
</script>
```

### With Options

```vue twoslash
<!-- @experimentalDefinePropProposal "kevinEdition" -->

<script setup lang="ts">
// Declare prop with options
const count = defineProp('count', {
  type: Number,
  required: true,
  default: 0,
  validator: (value: number) => value < 20,
})
</script>
```

### TypeScript

```vue twoslash
<!-- @experimentalDefinePropProposal "kevinEdition" -->

<script setup lang="ts">
// Declare prop of type number and infer prop name from variable name
const count = defineProp<number>()
count.value

// Declare prop of TS type boolean with default value
const disabled = defineProp<boolean>('disabled', { default: true })
disabled.value
</script>
```

### With Reactivity Transform

```vue twoslash
<!-- @experimentalDefinePropProposal "kevinEdition" -->

<script setup lang="ts">
const foo = $defineProp<string>('foo')

const bar = $(defineProp('bar', { default: 'bar' }))
</script>
```

## Johnson's Edition

### API Reference

```ts
// the prop name will be inferred from variable name
const propName = defineProp<T>()
const propName = defineProp<T>(defaultValue)
const propName = defineProp<T>(defaultValue, required)
const propName = defineProp<T>(defaultValue, required, rest)
```

### Basic Usage

```vue twoslash
<!-- @experimentalDefinePropProposal "johnsonEdition" -->

<script setup lang="ts">
// declare prop `count` with default value `0`
const count = defineProp(0)

// declare required prop `disabled`
const disabled = defineProp(undefined, true)

// access prop value
console.log(count.value, disabled.value)
</script>
```

### With Options

```vue twoslash
<!-- @experimentalDefinePropProposal "johnsonEdition" -->

<script setup lang="ts">
// Declare prop with options
const count = defineProp(0, false, {
  type: Number,
  validator: (value: number) => value < 20,
})
</script>
```

### TypeScript

```vue twoslash
<!-- @experimentalDefinePropProposal "johnsonEdition" -->

<script setup lang="ts">
const count = defineProp<number>()
count.value

// Declare prop of TS type boolean with default value
const disabled = defineProp<boolean>(true)
disabled.value
</script>
```

### With Reactivity Transform

```vue twoslash
<!-- @experimentalDefinePropProposal "johnsonEdition" -->

<script setup lang="ts">
const foo = $defineProp<number>()

const bar = $(defineProp(0, true))
</script>
```

### Volar Configuration

```jsonc {3,5} [tsconfig.json]
{
  "vueCompilerOptions": {
    "plugins": ["vue-macros/volar"],
    "vueMacros": {
      "defineProp": true,
    },
    // "kevinEdition" | "johnsonEdition" | false
    "experimentalDefinePropProposal": "kevinEdition",
  },
}
```

---

---
url: /zh-CN/macros/define-prop.md
---
# defineProp <PackageVersion name="@vue-macros/define-prop" />

<StabilityLevel level="experimental" />

使用 `defineProp` 逐个声明单个 prop。

|        特性        |        支持        |
| :----------------: | :----------------: |
|       Vue 3        | :white_check_mark: |
|       Nuxt 3       | :white_check_mark: |
|       Vue 2        | :white_check_mark: |
| TypeScript / Volar | :white_check_mark: |

::: warning

`defineProp` 不能与类型声明的 `defineProps` 在同一文件中使用。

:::

## Kevin 的版本

### API 参考

```ts
defineProp<T>(propName)
defineProp<T>(propName, options)

// propName 是参数可选的,
// 并且可从变量名中推断出
const propName = defineProp<T>()
```

### 基本用法

```vue twoslash
<!-- @experimentalDefinePropProposal "kevinEdition" -->

<script setup lang="ts">
// 声明 prop
const count = defineProp('count')

// 从变量名中推断出 prop 名称
const value = defineProp()

// 访问 prop 值
console.log(count.value)
</script>
```

### 选项

```vue twoslash
<!-- @experimentalDefinePropProposal "kevinEdition" -->

<script setup lang="ts">
// 使用选项声明 prop
const count = defineProp('count', {
  type: Number,
  required: true,
  default: 0,
  validator: (value: number) => value < 20,
})
</script>
```

### TypeScript

```vue twoslash
<!-- @experimentalDefinePropProposal "kevinEdition" -->

<script setup lang="ts">
// 使用类型为 number 的 prop 声明，并从变量名中推断 prop 的名称
const count = defineProp<number>()
count.value

// 使用默认值为 true 的 TS 类型为 boolean 的 prop 声明
const disabled = defineProp<boolean>('disabled', { default: true })
disabled.value
</script>
```

### 响应性语法糖

```vue twoslash
<!-- @experimentalDefinePropProposal "kevinEdition" -->

<script setup lang="ts">
const foo = $defineProp<string>('foo')

const bar = $(defineProp('bar', { default: 'bar' }))
</script>
```

## Johnson 的版本

### API 参考

```ts
// 从变量名中推断出 prop 名称
const propName = defineProp<T>()
const propName = defineProp<T>(defaultValue)
const propName = defineProp<T>(defaultValue, required)
const propName = defineProp<T>(defaultValue, required, rest)
```

### 基本用法

```vue twoslash
<!-- @experimentalDefinePropProposal "johnsonEdition" -->

<script setup lang="ts">
// 声明带有默认值 `0` 的 prop `count`
const count = defineProp(0)

// 声明必需的 prop `disabled`
const disabled = defineProp(undefined, true)

// 访问 prop 值
console.log(count.value, disabled.value)
</script>
```

### 选项

```vue twoslash
<!-- @experimentalDefinePropProposal "johnsonEdition" -->

<script setup lang="ts">
// 使用选项声明属性
const count = defineProp(0, false, {
  type: Number,
  validator: (value: number) => value < 20,
})
</script>
```

### TypeScript

```vue twoslash
<!-- @experimentalDefinePropProposal "johnsonEdition" -->

<script setup lang="ts">
const count = defineProp<number>()
count.value

// 使用默认值声明 TS 类型为 boolean 的属性
const disabled = defineProp<boolean>(true)
disabled.value
</script>
```

### 响应性语法糖

```vue twoslash
<!-- @experimentalDefinePropProposal "johnsonEdition" -->

<script setup lang="ts">
const foo = $defineProp<number>()

const bar = $(defineProp(0, true))
</script>
```

## Volar 配置

```jsonc {3,5} [tsconfig.json]
{
  "vueCompilerOptions": {
    "plugins": ["vue-macros/volar"],
    "vueMacros": {
      "defineProp": true,
    },
    // "kevinEdition" | "johnsonEdition" | false
    "experimentalDefinePropProposal": "kevinEdition",
  },
}
```

---

---
url: /macros/define-props.md
---
# defineProps <PackageVersion name="@vue-macros/define-props" />

<StabilityLevel level="stable" />

Correct types of destructured props using `$defineProps`.

See also [Vue issue](https://github.com/vuejs/core/issues/6876), [Reactivity Transform RFC](https://github.com/vuejs/rfcs/blob/reactivity-transform/active-rfcs/0000-reactivity-transform.md#defineprops-destructure-details).

|         Features          |     Supported      |
| :-----------------------: | :----------------: |
|           Vue 3           | :white_check_mark: |
|          Nuxt 3           | :white_check_mark: |
|           Vue 2           | :white_check_mark: |
| TypeScript / Volar Plugin | :white_check_mark: |

::: warning

[Reactivity Transform](../features/reactivity-transform.md) is required. You should enable it first.

:::

## Basic Usage

```vue twoslash
<script setup lang="ts">
const { foo } = $defineProps<{
  //     ^?
  foo: string[]
}>()

const fooRef = $$(foo)
//     ^?
</script>
```

## Volar Configuration

```jsonc {3} [tsconfig.json]
{
  "vueCompilerOptions": {
    "plugins": ["vue-macros/volar"],
  },
}
```

---

---
url: /zh-CN/macros/define-props.md
---
# defineProps <PackageVersion name="@vue-macros/define-props" />

<StabilityLevel level="stable" />

使用 `$defineProps` 可以正确地解构 `props` 的类型

参见 [Vue issue](https://github.com/vuejs/core/issues/6876), [Reactivity Transform RFC](https://github.com/vuejs/rfcs/blob/reactivity-transform/active-rfcs/0000-reactivity-transform.md#defineprops-destructure-details).

|           特性            |        支持        |
| :-----------------------: | :----------------: |
|           Vue 3           | :white_check_mark: |
|          Nuxt 3           | :white_check_mark: |
|           Vue 2           | :white_check_mark: |
| TypeScript / Volar Plugin | :white_check_mark: |

::: warning

在开始之前，你必须先开启 [响应性语法糖](../features/reactivity-transform.md)

:::

## 基本用法

```vue twoslash
<script setup lang="ts">
const { foo } = $defineProps<{
  //     ^?
  foo: string[]
}>()

const fooRef = $$(foo)
//     ^?
</script>
```

## Volar 配置

```jsonc {3} [tsconfig.json]
{
  "vueCompilerOptions": {
    "plugins": ["@vue-macros/volar/define-props"],
  },
}
```

---

---
url: /macros/define-props-refs.md
---
# definePropsRefs <PackageVersion name="@vue-macros/define-props-refs" />

<StabilityLevel level="stable" />

Returns refs from `defineProps` instead of a reactive object. It can be destructured without losing reactivity.

`toRefs(defineProps())` => `definePropsRefs()`

|         Features          |     Supported      |
| :-----------------------: | :----------------: |
|           Vue 3           | :white_check_mark: |
|          Nuxt 3           | :white_check_mark: |
|           Vue 2           | :white_check_mark: |
| TypeScript / Volar Plugin | :white_check_mark: |

## Basic Usage

```vue twoslash {2-3,8}
<script setup lang="ts">
// ✅ won't lose reactivity with destructuring
const { foo, bar } = definePropsRefs<{
  foo: string
  bar: number
}>()

console.log(foo.value, bar.value)
//           ^?
</script>
```

## With Default Value

```vue twoslash {2-3,8}
<script setup lang="ts">
import { withDefaults } from 'vue-macros/macros' with { type: 'macro' }

const { foo } = withDefaults(
  definePropsRefs<{
    foo?: string
  }>(),
  { foo: 'test' },
)

console.log(foo.value)
//           ^?
</script>
```

## Volar Configuration

```jsonc {3} [tsconfig.json]
{
  "vueCompilerOptions": {
    "plugins": ["vue-macros/volar"],
  },
}
```

---

---
url: /zh-CN/macros/define-props-refs.md
---
# definePropsRefs <PackageVersion name="@vue-macros/define-props-refs" />

<StabilityLevel level="stable" />

从 `defineProps` 中将返回 refs 而不是 reactive 对象，可以在不丢失响应式的情况下解构 props。

`toRefs(defineProps())` => `definePropsRefs()`

|           特性            |        支持        |
| :-----------------------: | :----------------: |
|           Vue 3           | :white_check_mark: |
|          Nuxt 3           | :white_check_mark: |
|           Vue 2           | :white_check_mark: |
| TypeScript / Volar Plugin | :white_check_mark: |

## 基本用法

```vue twoslash {2-3,8}
<script setup lang="ts">
// ✅ 解构不丢失响应式
const { foo, bar } = definePropsRefs<{
  foo: string
  bar: number
}>()

console.log(foo.value, bar.value)
//           ^?
</script>
```

## 默认值

```vue twoslash {2-3,8}
<script setup lang="ts">
import { withDefaults } from 'vue-macros/macros' with { type: 'macro' }

const { foo } = withDefaults(
  definePropsRefs<{
    foo?: string
  }>(),
  { foo: 'test' },
)

console.log(foo.value)
//           ^?
</script>
```

## Volar 配置

```jsonc {3} [tsconfig.json]
{
  "vueCompilerOptions": {
    "plugins": ["vue-macros/volar"],
  },
}
```

---

---
url: /macros/define-render.md
---
# defineRender <PackageVersion name="@vue-macros/define-render" />

<StabilityLevel level="stable" />

Defining render function in `<script setup>` using the `defineRender`.

|  Features  |     Supported      |
| :--------: | :----------------: |
|   Vue 3    | :white_check_mark: |
|   Nuxt 3   | :white_check_mark: |
|   Vue 2    | :white_check_mark: |
| TypeScript | :white_check_mark: |

We need more feedback on [RFC Discussion](https://github.com/vuejs/rfcs/discussions/585)!

## Basic Usage

```vue twoslash
<script setup lang="tsx">
// JSX passed directly
defineRender(
  <div>
    <span>Hello</span>
  </div>,
)

// Or using render function
defineRender(() => {
  return (
    <div>
      <h1>Hello World</h1>
    </div>
  )
})
</script>
```

---

---
url: /zh-CN/macros/define-render.md
---
# defineRender <PackageVersion name="@vue-macros/define-render" />

<StabilityLevel level="stable" />

使用 `defineRender` 可以直接在 `<script setup>` 中定义渲染函数。

|    特性    |        支持        |
| :--------: | :----------------: |
|   Vue 3    | :white_check_mark: |
|   Nuxt 3   | :white_check_mark: |
|   Vue 2    | :white_check_mark: |
| TypeScript | :white_check_mark: |

在 [RFC 讨论](https://github.com/vuejs/rfcs/discussions/585) 中，我们需要更多的反馈！

## 基本用法

```vue twoslash
<script setup lang="tsx">
// 可以直接传递 JSX
defineRender(
  <div>
    <span>Hello</span>
  </div>,
)

// 或使用渲染函数
defineRender(() => {
  return (
    <div>
      <h1>Hello World</h1>
    </div>
  )
})
</script>
```

---

---
url: /macros/define-slots.md
---
# defineSlots <PackageVersion name="@vue-macros/define-slots" />

<StabilityLevel level="stable" />

Declaring type of SFC slots in `<script setup>` using the `defineSlots`.

For Vue >= 3.3, this feature will be turned off by default.

|   Features   |     Supported      |
| :----------: | :----------------: |
|    Vue 3     | :white_check_mark: |
|    Nuxt 3    | :white_check_mark: |
| Volar Plugin | :white_check_mark: |
|    Vue 2     |        :x:         |

## Basic Usage

### Short Syntax

```vue twoslash
<script setup lang="ts">
defineSlots<{
  // slot name
  title: {
    // scoped slot
    foo: 'bar' | boolean
  }
}>()
</script>
```

### Full Syntax (Official Version)

```vue twoslash
<script setup lang="ts">
defineSlots<{
  title: (scope: { text: string }) => any
}>()
</script>
```

## Volar Configuration

```jsonc {3} [tsconfig.json]
{
  "vueCompilerOptions": {
    "plugins": ["vue-macros/volar"],
  },
}
```

---

---
url: /zh-CN/macros/define-slots.md
---
# defineSlots <PackageVersion name="@vue-macros/define-slots" />

<StabilityLevel level="stable" />

使用 `defineSlots` 可以在 `<script setup>` 中声明 SFC 中插槽的类型

在 Vue >= 3.3 中，此功能将默认关闭。

|     特性     |        支持        |
| :----------: | :----------------: |
|    Vue 3     | :white_check_mark: |
|    Nuxt 3    | :white_check_mark: |
| Volar Plugin | :white_check_mark: |
|    Vue 2     |        :x:         |

## 基本用法

### 简写语法

```vue twoslash
<script setup lang="ts">
defineSlots<{
  // 插槽名称
  title: {
    // 作用域插槽
    foo: 'bar' | boolean
  }
}>()
</script>
```

### 完整语法（官方版本）

```vue twoslash
<script setup lang="ts">
defineSlots<{
  title: (scope: { text: string }) => any
}>()
</script>
```

## Volar 配置

```jsonc {3} [tsconfig.json]
{
  "vueCompilerOptions": {
    "plugins": ["vue-macros/volar"],
  },
}
```

---

---
url: /macros/define-stylex.md
---
# defineStyleX <PackageVersion name="@vue-macros/define-stylex" />

<StabilityLevel level="experimental" />

Define and consume [StyleX](https://stylexjs.com/) styles in `<script setup>`.

|      Features      |     Supported      |
| :----------------: | :----------------: |
|       Vue 3        | :white_check_mark: |
|       Nuxt 3       | :white_check_mark: |
| TypeScript / Volar | :white_check_mark: |
|       Vue 2        | :white_check_mark: |

## Setup

To use StyleX, you should install and configure StyleX first. The steps could change, you may want to check the [official documentation](https://stylexjs.com/) and the [documentation of vite-plugin-stylex](https://github.com/HorusGoul/vite-plugin-stylex) for the latest information.

### Vite

```sh
pnpm add @stylexjs/stylex vite-plugin-stylex
```

```ts [vite.config.ts] {4,13}
import Vue from '@vitejs/plugin-vue'
import { defineConfig } from 'vite'
import StyleX from 'vite-plugin-stylex'
import VueMacros from 'vue-macros/vite'

export default defineConfig({
  plugins: [
    VueMacros({
      plugins: {
        vue: Vue(),
      },
    }),
    StyleX(), // Must be placed after Vue Macros
  ],
})
```

```vue [App.vue] {2-3}
<style>
/* import StyleX stylesheet, according to https://github.com/HorusGoul/vite-plugin-stylex */
@stylex stylesheet;
</style>
```

## Basic Usage

```vue [App.vue] twoslash
<script setup lang="ts">
const styles = defineStyleX({
  red: { color: 'red' },
})

// ...
// ---cut-start---
declare const vStylex: any
// ---cut-end---
</script>

<template>
  <p v-stylex="styles.red">Red</p>
</template>
```

:::details Compiled Code (with some simplifications)

```vue [App.vue] twoslash
<script lang="ts">
const styles = _stylex_create({
  red: { color: 'red' },
})
</script>

<script setup lang="ts">
import {
  attrs as _stylex_attrs,
  create as _stylex_create,
} from '@stylexjs/stylex'

// ...
</script>

<template>
  <p v-bind="_stylex_attrs(styles.red)">Red</p>
</template>
```

:::

## Conditional Styles

Optional and multiple rules are supported.

```vue [App.vue] twoslash
<script setup lang="ts">
defineProps<{ bold?: boolean }>()

const styles = defineStyleX({
  red: { color: 'red' },
  bold: { fontWeight: 'bold' },
})
// ---cut-start---
declare const vStylex: any
// ---cut-end---
</script>

<template>
  <span v-stylex="(styles.red, bold && styles.bold)">Red</span>
</template>
```

:::details Compiled Code (with some simplifications)

```vue [App.vue] twoslash
<script lang="ts">
const styles = _stylex_create({
  red: { color: 'red' },
  bold: { fontWeight: 'bold' },
})
</script>

<script setup lang="ts">
import {
  attrs as _stylex_attrs,
  create as _stylex_create,
} from '@stylexjs/stylex'

defineProps<{ bold?: boolean }>()
</script>

<template>
  <span v-bind="_stylex_attrs(styles.red, bold && styles.bold)">Red</span>
</template>
```

:::

---

---
url: /zh-CN/macros/define-stylex.md
---
# defineStyleX <PackageVersion name="@vue-macros/define-stylex" />

<StabilityLevel level="experimental" />

在 `<script setup>` 定义与使用 [StyleX](https://stylexjs.com/) 的 Atomic CSS-in-JS.

|      Features      |     Supported      |
| :----------------: | :----------------: |
|       Vue 3        | :white_check_mark: |
|       Nuxt 3       | :white_check_mark: |
| TypeScript / Volar | :white_check_mark: |
|       Vue 2        | :white_check_mark: |

## 配置

在使用这个宏之前，你需要先引入与配置 StyleX。步骤可能会有所变化，你可能需要查看 [StyleX 官方文档](https://stylexjs.com/) 以及 [vite-plugin-stylex](https://github.com/HorusGoul/vite-plugin-stylex) 的文档，以获取最新信息。

### Vite

```sh
pnpm add @stylexjs/stylex vite-plugin-stylex
```

```ts [vite.config.ts] {4,13}
import Vue from '@vitejs/plugin-vue'
import { defineConfig } from 'vite'
import StyleX from 'vite-plugin-stylex'
import VueMacros from 'vue-macros/vite'

export default defineConfig({
  plugins: [
    VueMacros({
      plugins: {
        vue: Vue(),
      },
    }),
    StyleX(), // 必须放在 Vue Macros 插件后
  ],
})
```

```vue [App.vue] {2-3}
<style>
/* 引入 StyleX 样式表, 参考： https://github.com/HorusGoul/vite-plugin-stylex */
@stylex stylesheet;
</style>
```

## 基本用法

```vue [App.vue] twoslash
<script setup lang="ts">
const styles = defineStyleX({
  red: { color: 'red' },
})

// ...
// ---cut-start---
declare const vStylex: any
// ---cut-end---
</script>

<template>
  <p v-stylex="styles.red">Red</p>
</template>
```

:::details 编译结果（有所简化）

```vue [App.vue] twoslash
<script lang="ts">
const styles = _stylex_create({
  red: { color: 'red' },
})
</script>

<script setup lang="ts">
import {
  attrs as _stylex_attrs,
  create as _stylex_create,
} from '@stylexjs/stylex'

// ...
</script>

<template>
  <p v-bind="_stylex_attrs(styles.red)">Red</p>
</template>
```

:::

## 条件样式

你可以应用多个样式，也可以根据条件应用样式。

```vue [App.vue] twoslash
<script setup lang="ts">
defineProps<{ bold?: boolean }>()

const styles = defineStyleX({
  red: { color: 'red' },
  bold: { fontWeight: 'bold' },
})
// ---cut-start---
declare const vStylex: any
// ---cut-end---
</script>

<template>
  <span v-stylex="(styles.red, bold && styles.bold)">Red</span>
</template>
```

:::details 编译结果（有所简化）

```vue [App.vue] twoslash
<script lang="ts">
const styles = _stylex_create({
  red: { color: 'red' },
  bold: { fontWeight: 'bold' },
})
</script>

<script setup lang="ts">
import {
  attrs as _stylex_attrs,
  create as _stylex_create,
} from '@stylexjs/stylex'

defineProps<{ bold?: boolean }>()
</script>

<template>
  <span v-bind="_stylex_attrs(styles.red, bold && styles.bold)">Red</span>
</template>
```

:::

---

---
url: /features/export-expose.md
---
# exportExpose <PackageVersion name="@vue-macros/export-expose" />

<StabilityLevel level="experimental" />

Transform export statement as `defineExpose` params in Vue SFC `script-setup`.

|   Features   |     Supported      |
| :----------: | :----------------: |
|    Vue 3     | :white_check_mark: |
|    Nuxt 3    |         ?          |
|    Vue 2     | :white_check_mark: |
| Volar Plugin | :white_check_mark: |

## Usage

Support these syntaxes:

- local variable/function/class
- export with alias
- export from other file
- namespace export
- rename export

### 1. local variable/function/class

```vue twoslash
<script setup lang="ts">
export const foo: string = 'foo',
  bar = 10
export let baz: string | undefined
export var qux = fn()
// @errors: 2448 2454 2695
export const { a, b, c } = { a: 1, b: 2, c: 3 }

export function fn() {}
export class A {}
</script>
```

::: details Compiled Code

```vue twoslash
<script setup lang="ts">
const foo: string = 'foo',
  bar = 10
let baz: string | undefined
const qux = fn()
const { a, b, c } = { a: 1, b: 2, c: 3 }

function fn() {}
class A {}

defineExpose({
  foo,
  bar,
  baz,
  qux,
  a,
  b,
  c,
  fn,
  A,
})
</script>
```

:::

### 2. export with alias

```vue twoslash
<script setup lang="ts">
const foo = ''

export { foo as foo1 }
</script>
```

::: details Compiled Code

```vue twoslash
<script setup lang="ts">
const foo = 'foo'

defineExpose({
  foo1: foo,
})
</script>
```

:::

### 3. export from other file

::: code-group

```vue [App.vue] twoslash
<script setup lang="ts">
// #region export-file
const foo = 'foo'
type Foo = string

export { foo, type Foo }
// #endregion export-file
// ---cut---
// @noErrors
export { foo as bar, foo, type Foo } from './types'
</script>
```

<<< ./export-expose.md#export-file{ts} [types.ts]

:::

::: details Compiled Code

```vue twoslash
<script setup lang="ts">
const __MACROS_expose_0 = 'foo'
const __MACROS_expose_1 = 'foo'
type Foo = string
// ---cut---
// @noErrors
import {
  foo as __MACROS_expose_0,
  foo as __MACROS_expose_1,
  type Foo,
} from './types'
defineExpose({
  foo: __MACROS_expose_0,
  bar: __MACROS_expose_1,
})
</script>
```

:::

### 4. namespace export

::: code-group

```vue [App.vue] twoslash
<script setup lang="ts">
const foo = { foo: 'foo' }
// ---cut---
// @noErrors
export * as foo from './types'
</script>
```

```ts [types.ts]
export const foo = 'foo'
```

:::

::: details Compiled Code

```vue twoslash
<script setup lang="ts">
const __MACROS_expose_0 = {
  foo: 'foo',
}
// ---cut---
// @noErrors
import * as __MACROS_expose_0 from './types'
defineExpose({
  foo: __MACROS_expose_0,
})
</script>
```

:::

### 5. rename export

```vue
<script setup lang="ts">
const foo = 1,
  bar = 1

export { foo } from './types'
export * as bar from './types'
</script>
```

::: details Compiled Code

```vue
<script setup lang="ts">
import { foo as __MACROS_expose_0 } from './types'
import * as __MACROS_expose_1 from './types'

const foo = 1,
  bar = 1
defineExpose({
  foo: __MACROS_expose_0,
  bar: __MACROS_expose_1,
})
</script>
```

:::

## Limitations

Currently does't support these following cases:

```ts
// 1. export all ❌
export * from '../types'

// 2. export default ❌
const a = 'a'
export default a
```

## Volar Configuration

```jsonc {3,5} [tsconfig.json]
{
  "vueCompilerOptions": {
    "plugins": ["vue-macros/volar"],
    "vueMacros": {
      "exportExpose": true,
    },
  },
}
```

---

---
url: /zh-CN/features/export-expose.md
---
# exportExpose <PackageVersion name="@vue-macros/export-expose" />

<StabilityLevel level="experimental" />

在 Vue SFC `script-setup` 中将 export 语句转换为 `defineExpose` 参数。

|     特性     |        支持        |
| :----------: | :----------------: |
|    Vue 3     | :white_check_mark: |
|    Nuxt 3    |         ?          |
|    Vue 2     | :white_check_mark: |
| Volar Plugin | :white_check_mark: |

## 用法

支持以下语法：

- 局部变量/函数/类
- 别名导出
- 从其他文件导出
- 命名空间导出
- 重命名导出

### 1. 局部变量/函数/类

```vue twoslash
<script setup lang="ts">
export const foo: string = 'foo',
  bar = 10
export let baz: string | undefined
export var qux = fn()
// @errors: 2448 2454 2695
export const { a, b, c } = { a: 1, b: 2, c: 3 }

export function fn() {}
export class A {}
</script>
```

::: details 编译后代码

```vue twoslash
<script setup lang="ts">
const foo: string = 'foo',
  bar = 10
let baz: string | undefined
const qux = fn()
const { a, b, c } = { a: 1, b: 2, c: 3 }

function fn() {}
class A {}

defineExpose({
  foo,
  bar,
  baz,
  qux,
  a,
  b,
  c,
  fn,
  A,
})
</script>
```

:::

### 2. 别名导出

```vue twoslash
<script setup lang="ts">
const foo = ''

export { foo as foo1 }
</script>
```

::: details 编译后代码

```vue twoslash
<script setup lang="ts">
const foo = 'foo'

defineExpose({
  foo1: foo,
})
</script>
```

:::

### 3. 从其他文件导出

::: code-group

```vue [App.vue] twoslash
<script setup lang="ts">
// #region export-file
const foo = 'foo'
type Foo = string

export { foo, type Foo }
// #endregion export-file
// ---cut---
// @noErrors
export { foo as bar, foo, type Foo } from './types'
</script>
```

<<< ./export-expose.md#export-file{ts} [types.ts]

:::

::: details 编译后代码

```vue twoslash
<script setup lang="ts">
const __MACROS_expose_0 = 'foo'
const __MACROS_expose_1 = 'foo'
type Foo = string
// ---cut---
// @noErrors
import {
  foo as __MACROS_expose_0,
  foo as __MACROS_expose_1,
  type Foo,
} from './types'
defineExpose({
  foo: __MACROS_expose_0,
  bar: __MACROS_expose_1,
})
</script>
```

:::

### 4. 命名空间导出

::: code-group

```vue [App.vue] twoslash
<script setup lang="ts">
const foo = { foo: 'foo' }
// ---cut---
// @noErrors
export * as foo from './types'
</script>
```

```ts [types.ts]
export const foo = 'foo'
```

:::

::: details 编译后代码

```vue twoslash
<script setup lang="ts">
const __MACROS_expose_0 = {
  foo: 'foo',
}
// ---cut---
// @noErrors
import * as __MACROS_expose_0 from './types'
defineExpose({
  foo: __MACROS_expose_0,
})
</script>
```

:::

### 5. 重命名导出

```vue
<script setup lang="ts">
const foo = 1,
  bar = 1

export { foo } from './types'
export * as bar from './types'
</script>
```

::: details 编译后代码

```vue
<script setup lang="ts">
import { foo as __MACROS_expose_0 } from './types'
import * as __MACROS_expose_1 from './types'

const foo = 1,
  bar = 1
defineExpose({
  foo: __MACROS_expose_0,
  bar: __MACROS_expose_1,
})
</script>
```

:::

## 限制

当前不支持以下语法：

```ts
// 1. 全部导出 ❌
export * from '../types'

// 2. 默认导出 ❌
const a = 'a'
export default a
```

## Volar 配置

```jsonc {3,5} [tsconfig.json]
{
  "vueCompilerOptions": {
    "plugins": ["vue-macros/volar"],
  },
  "vueMacros": {
    "exportExpose": true,
  },
}
```

---

---
url: /features/export-props.md
---
# exportProps <PackageVersion name="@vue-macros/define-props" />

<StabilityLevel level="experimental" />

[Svelte-like Declaring props](https://svelte.dev/docs#component-format-script-1-export-creates-a-component-prop) for Vue.

|   Features   |     Supported      |
| :----------: | :----------------: |
|    Vue 3     | :white_check_mark: |
|    Nuxt 3    |     :question:     |
|    Vue 2     | :white_check_mark: |
| Volar Plugin | :white_check_mark: |

## Pre-requisite

[Reactivity Transform](./reactivity-transform.md) is required to use this feature, but it is enabled by default in Vue Macros.

`export let` will be changed to `defineModel`, which is supported in Vue 3.4+.

## Usage

Using export syntax to declare props.

```vue twoslash
<script setup lang="ts">
export let foo: string
export const bar: number = 1 // with default value
</script>
```

## Volar Configuration

```jsonc {3,5} [tsconfig.json]
{
  "vueCompilerOptions": {
    "plugins": ["vue-macros/volar"],
    "vueMacros": {
      "exportProps": true,
    },
  },
}
```

---

---
url: /zh-CN/features/export-props.md
---
# exportProps <PackageVersion name="@vue-macros/define-props" />

<StabilityLevel level="experimental" />

在 Vue 中使用 [Svelte 风格声明 `props`](https://svelte.dev/docs#component-format-script-1-export-creates-a-component-prop)。

|     特性     |        支持        |
| :----------: | :----------------: |
|    Vue 3     | :white_check_mark: |
|    Nuxt 3    |         ?          |
|    Vue 2     | :white_check_mark: |
| Volar Plugin | :white_check_mark: |

## 前置条件

要使用此功能，需要 [Reactivity Transform](./reactivity-transform.md)，
但在 Vue Macros 中已经默认启用。

`export let` 将编译为 `defineModel`，该功能在 Vue 3.4+ 中受支持。

## 用法

使用导出语法来声明 `props`。

```vue twoslash
<script setup lang="ts">
export let foo: string
export const bar: number = 1 // 带有默认值
</script>
```

## Volar 配置

```jsonc {3,5} [tsconfig.json]
{
  "vueCompilerOptions": {
    "plugins": ["vue-macros/volar"],
  },
  "vueMacros": {
    "exportProps": true,
  },
}
```

---

---
url: /features/export-render.md
---
# exportRender <PackageVersion name="@vue-macros/export-render" />

<StabilityLevel level="experimental" />

Transform the default export statement, in `<script setup>` of Vue SFC, as a component render function.

|   Features   |     Supported      |
| :----------: | :----------------: |
|    Vue 3     | :white_check_mark: |
|    Nuxt 3    |     :question:     |
|    Vue 2     | :white_check_mark: |
| Volar Plugin | :white_check_mark: |

::: tip

This feature depends on `defineRender`, and make sure `defineRender` is not disabled.

:::

## Usage

```vue
<script setup lang="tsx">
// JSX passed directly
export default <div>ok</div>

// Or using render function
export default () => <div>ok</div>
</script>
```

## Volar Configuration

```jsonc {3,7} [tsconfig.json]
{
  "vueCompilerOptions": {
    "plugins": ["vue-macros/volar"],
    "vueMacros": {
      "exportRender": true,
    },
  },
}
```

---

---
url: /zh-CN/features/export-render.md
---
# exportRender <PackageVersion name="@vue-macros/export-render" />

<StabilityLevel level="experimental" />

在 Vue SFC 的 `<script setup>` 中，把 export default 语句转换为组件的渲染函数。

|   Features   |     Supported      |
| :----------: | :----------------: |
|    Vue 3     | :white_check_mark: |
|    Nuxt 3    |     :question:     |
|    Vue 2     | :white_check_mark: |
| Volar Plugin | :white_check_mark: |

::: tip

这个特性依赖于 `defineRender`，并确保 `defineRender` 没有被禁用。

:::

## 用法

```vue
<script setup lang="tsx">
// 可以直接传递 JSX
export default <div>ok</div>

// 或使用渲染函数
export default () => <div>ok</div>
</script>
```

## Volar 配置

```jsonc {3,7} [tsconfig.json]
{
  "vueCompilerOptions": {
    "plugins": ["vue-macros/volar"],
    "vueMacros": {
      "exportRender": true,
    },
  },
}
```

---

---
url: /guide/getting-started.md
---
<script setup>
import { version } from 'vue-tsc/package.json'
</script>

# Getting Started

Vue Macros is a library that implements unofficial proposals and ideas for Vue,
exploring and extending its features and syntax.

We assume you are already familiar with the basic usages of Vue before you continue.

## Requirements

- Node.js `>= v20.18.0`.
- Vue `>= v2.7` or Vue `>= v3.0`.
  - Some features need Vue `>= v3.2.25`.
- VSCode extension [Vue - Official](https://marketplace.visualstudio.com/items?itemName=Vue.volar) and `vue-tsc` are <code>v{{ version }}</code>
  - Vue Macros will continue to adapt to the latest version as soon as possible, older versions may not be supported.

::: warning
WebStorm is not supported.
:::

## Creating a Vue Macros Project

### Installation

::: code-group

```bash [npm]
npm i -g @vue-macros/cli
```

```bash [yarn]
yarn global add @vue-macros/cli
```

```bash [pnpm]
pnpm add -g @vue-macros/cli
```

:::

This command will install [@vue-macros/cli](https://github.com/vue-macros/vue-macros-cli), the official Vue Macros scaffolding tool.

### Initialization

::: code-group

```bash [npm]
npm create vite@latest my-vue-macros -- --template vue-ts
cd my-vue-macros
vue-macros init
```

```bash [yarn]
yarn create vite my-vue-macros --template vue-ts
cd my-vue-macros
vue-macros init
```

```bash [pnpm]
pnpm create vite my-vue-macros --template vue-ts
cd my-vue-macros
vue-macros init
```

You will be presented with prompts for several optional experimental features.

:::

## Templates

- [Vite](https://github.com/vue-macros/vite)
- [Nuxt](https://github.com/vue-macros/nuxt)
- [Rsbuild](https://github.com/vue-macros/vue3-rsbuild)

🌟 More templates are welcome!

## Nuxt Integration

If you're using [Nuxt](https://nuxt.com/), read the [Nuxt Integration](./nuxt-integration.md).

## Bundler Integrations

If you're using [Vite](https://vitejs.dev/), [Rollup](https://rollupjs.org/), [esbuild](https://esbuild.github.io/), [Webpack](https://webpack.js.org/), or [Rspack](https://www.rspack.dev/), read the [Bundler Integration](./bundler-integration.md).

---

---
url: /features/hoist-static.md
---
# hoistStatic <PackageVersion name="@vue-macros/hoist-static" />

<StabilityLevel level="stable" />

With enabling `hoistStatic`, constants declared in macros of `<script setup>` can be referenced.

For Vue >= 3.3, this feature will be turned off by default.

| Features |     Supported      |
| :------: | :----------------: |
|  Vue 3   | :white_check_mark: |
|  Nuxt 3  | :white_check_mark: |
|  Vue 2   | :white_check_mark: |

## Basic Usage

```vue twoslash
<script setup lang="ts">
const name = 'AppFoo'
defineOptions({
  name,
})
</script>
```

::: details Compiled Code

```vue
<script lang="ts">
const name = 'AppFoo'
export default {
  name,
}
</script>
```

:::

## Magic Comments

```vue
<script setup lang="ts">
// A value that's even not a constant
const name = /* hoist-static */ fn()
defineOptions({
  name,
})
</script>
```

::: details Compiled Code

```vue
<script lang="ts">
const name = fn()
export default {
  name,
}
</script>
```

:::

---

---
url: /zh-CN/features/hoist-static.md
---
# hoistStatic <PackageVersion name="@vue-macros/hoist-static" />

<StabilityLevel level="stable" />

通过开启 `hoistStatic`, 可以在宏内部引用 `<script setup>` 中的变量

在 Vue >= 3.3 中，此功能将默认关闭。

|  特性  |        支持        |
| :----: | :----------------: |
| Vue 3  | :white_check_mark: |
| Nuxt 3 | :white_check_mark: |
| Vue 2  | :white_check_mark: |

## 基本用法

```vue twoslash
<script setup lang="ts">
const name = 'AppFoo'
defineOptions({
  name,
})
</script>
```

::: details 编译后的代码

```vue
<script lang="ts">
const name = 'AppFoo'
export default {
  name,
}
</script>
```

:::

## 魔法注释

```vue
<script setup lang="ts">
// 甚至不是常量的值
const name = /* hoist-static */ fn()
defineOptions({
  name,
})
</script>
```

::: details 编译后的代码

```vue
<script lang="ts">
const name = fn()
export default {
  name,
}
</script>
```

:::

---

---
url: /features/jsx-directive.md
---
# jsxDirective <PackageVersion name="@vue-macros/jsx-directive" />

<StabilityLevel level="stable" />

Vue built-in directives for JSX.

|  Directive  |       Vue 3        |       Vue 2        |       Volar        |
| :---------: | :----------------: | :----------------: | :----------------: |
|   `v-if`    | :white_check_mark: | :white_check_mark: | :white_check_mark: |
| `v-else-if` | :white_check_mark: | :white_check_mark: | :white_check_mark: |
|  `v-else`   | :white_check_mark: | :white_check_mark: | :white_check_mark: |
|   `v-for`   | :white_check_mark: | :white_check_mark: | :white_check_mark: |
|   `v-on`    | :white_check_mark: | :white_check_mark: | :white_check_mark: |
|  `v-slot`   | :white_check_mark: | :white_check_mark: | :white_check_mark: |
|  `v-html`   | :white_check_mark: | :white_check_mark: |         /          |
|  `v-once`   | :white_check_mark: |        :x:         |         /          |
|  `v-memo`   | :white_check_mark: |        :x:         |         /          |

## Options

```ts
interface Options {
  /**
   * @default 'v-'
   */
  prefix?: string
  /**
   * @default 'vue'
   */
  lib?: 'vue' | 'react' | 'preact' | 'solid' | string
}
```

## Usage

### `v-if`, `v-else-if`, `v-else`

```vue twoslash
<script setup lang="tsx">
const { foo } = defineProps<{
  foo: number
}>()

// ---cut-start---
// prettier-ignore
// ---cut-end---
export default () => (
  <>
    <div v-if={foo === 0}>{foo}</div>

    <div v-else-if={foo === 1}>{foo}</div>
    //                          ^?

    <div v-else>{foo}</div>
    //           ^?
  </>
)
</script>
```

### `v-for`

```vue twoslash
<script setup lang="tsx">
export default () => (
  <div v-for={(item, index) in 4} key={index}>
    {item}
  </div>
)
</script>
```

### `v-slot`

::: code-group

```vue [App.vue] twoslash
<script lang="tsx" setup>
// #region v-slot
import type { FunctionalComponent } from 'vue'

export const Comp: FunctionalComponent<
  {},
  {},
  {
    default: () => any
    slot: (scope: { bar: number }) => any
    slots: (scope: { baz: boolean }) => any
  }
> = () => <div />
// #endregion v-slot
// ---cut---
// @noErrors
import { Comp } from './Comp.tsx'

// ---cut-start---
// prettier-ignore
// ---cut-end---
export default () => (
  <Comp>
    default slot...
    <template v-slot:slot={{ bar }}>
      //              ^|
      {bar}
    </template>
  </Comp>
)
</script>
```

<<< ./jsx-directive.md#v-slot{tsx} [Child.tsx]

:::

### `v-on`

::: warning

`v-on` only supports binding to an object of event / listener pairs without an argument.

:::

```tsx
<form v-on={{ submit }} />
```

## Dynamic Arguments

It is also possible to use a variable in a directive argument by wrapping it with a pair of `$`:

`v-model`

::: code-group

```vue [App.vue] twoslash
<script setup lang="tsx">
// ---cut-start---
// #region v-model
import { ref, type FunctionalComponent } from 'vue'

export const Comp: FunctionalComponent<
  {
    model: string
    models: string[]
  },
  {
    'update:model': [value: string]
    'update:models': [value: string[]]
  }
> = () => <div />
// #endregion v-model
// ---cut-end---
// @noErrors
import { Comp } from './Comp.tsx'

const name = ref('model')
const model = defineModel<string>()

export default () => (
  <Comp
    v-model:$name$={model.value}
    v-model:model={model.value}
    //       ^|
  />
)
</script>
```

<<< ./jsx-directive.md#v-model{tsx} [Comp.tsx]

:::

`v-slot`

::: code-group

```vue [App.vue] twoslash
<script setup lang="tsx">
// ---cut-start---
// #region v-slot-dynamic
import type { FunctionalComponent } from 'vue'

export const Comp: FunctionalComponent<
  {},
  {},
  {
    default: (scope: { foo: string }) => any
    title: (scope: { bar: number }) => any
  }
> = () => <div />
// #endregion v-slot-dynamic
// ---cut-end---
// @noErrors
import { Comp } from './Comp.tsx'

const slots = defineSlots<{
  default: (scope: { foo: string }) => any
  title: (scope: { bar: number }) => any
}>()

// ---cut-start---
// prettier-ignore
// ---cut-end---
export default () => (
  <Comp>
    <template v-for={(Slot, name) in slots} v-slot:$name$={scope}>
      //                                             ^?
      <Slot {...scope} />
    </template>
  </Comp>
)
</script>
```

<<< ./jsx-directive.md#v-slot-dynamic{tsx} [Comp.tsx]

:::

## Modifiers

Modifiers are special postfixes denoted by a `_`, which indicate that a directive should be bound in some special way.

```tsx
<form onSubmit_prevent>
  <input v-model_number={value} />
</form>
```

## Volar Configuration

```jsonc {3} [tsconfig.json]
{
  "vueCompilerOptions": {
    "plugins": ["vue-macros/volar"],
  },
}
```

---

---
url: /zh-CN/features/jsx-directive.md
---
# jsxDirective <PackageVersion name="@vue-macros/jsx-directive" />

<StabilityLevel level="stable" />

在 JSX 中使用 Vue 内置指令。

|    指令     |       Vue 3        |       Vue 2        |       Volar        |
| :---------: | :----------------: | :----------------: | :----------------: |
|   `v-if`    | :white_check_mark: | :white_check_mark: | :white_check_mark: |
| `v-else-if` | :white_check_mark: | :white_check_mark: | :white_check_mark: |
|  `v-else`   | :white_check_mark: | :white_check_mark: | :white_check_mark: |
|   `v-for`   | :white_check_mark: | :white_check_mark: | :white_check_mark: |
|   `v-on`    | :white_check_mark: | :white_check_mark: | :white_check_mark: |
|  `v-slot`   | :white_check_mark: | :white_check_mark: | :white_check_mark: |
|  `v-html`   | :white_check_mark: | :white_check_mark: |         /          |
|  `v-once`   | :white_check_mark: |        :x:         |         /          |
|  `v-memo`   | :white_check_mark: |        :x:         |         /          |

## 选项

```ts
interface Options {
  /**
   * @default 'v-'
   */
  prefix?: string
  /**
   * @default 'vue'
   */
  lib?: 'vue' | 'react' | 'preact' | 'solid' | string
}
```

## 用法

### `v-if`, `v-else-if`, `v-else`

```vue twoslash
<script setup lang="tsx">
const { foo } = defineProps<{
  foo: number
}>()

// ---cut-start---
// prettier-ignore
// ---cut-end---
export default () => (
  <>
    <div v-if={foo === 0}>{foo}</div>

    <div v-else-if={foo === 1}>{foo}</div>
    //                          ^?

    <div v-else>{foo}</div>
    //           ^?
  </>
)
</script>
```

### `v-for`

```vue twoslash
<script setup lang="tsx">
export default () => (
  <div v-for={(item, index) in 4} key={index}>
    {item}
  </div>
)
</script>
```

### `v-slot`

::: code-group

```vue [App.vue] twoslash
<script lang="tsx" setup>
// #region v-slot
import type { FunctionalComponent } from 'vue'

export const Comp: FunctionalComponent<
  {},
  {},
  {
    default: () => any
    slot: (scope: { bar: number }) => any
    slots: (scope: { baz: boolean }) => any
  }
> = () => <div />
// #endregion v-slot
// ---cut---
// @noErrors
import { Comp } from './Comp.tsx'

// ---cut-start---
// prettier-ignore
// ---cut-end---
export default () => (
  <Comp>
    default slot...
    <template v-slot:slot={{ bar }}>
      //              ^|
      {bar}
    </template>
  </Comp>
)
</script>
```

<<< ./jsx-directive.md#v-slot{tsx} [Child.tsx]

:::

### `v-on`

::: warning

`v-on` 仅支持绑定不带参数的事件/监听器对的对象。

:::

```tsx
<form v-on={{ submit }} />
```

## 动态参数

在指令参数上也可以使用一个变量，需要包含在一对 `$` 内：

`v-model`

::: code-group

```vue [App.vue] twoslash
<script setup lang="tsx">
// ---cut-start---
// #region v-model
import { ref, type FunctionalComponent } from 'vue'

export const Comp: FunctionalComponent<
  {
    model: string
    models: string[]
  },
  {
    'update:model': [value: string]
    'update:models': [value: string[]]
  }
> = () => <div />
// #endregion v-model
// ---cut-end---
// @noErrors
import { Comp } from './Comp.tsx'

const name = ref('model')
const model = defineModel<string>()

export default () => (
  <Comp
    v-model:$name$={model.value}
    v-model:model={model.value}
    //       ^|
  />
)
</script>
```

<<< ./jsx-directive.md#v-model{tsx} [Comp.tsx]

:::

`v-slot`

::: code-group

```vue [App.vue] twoslash
<script setup lang="tsx">
// ---cut-start---
// #region v-slot-dynamic
import type { FunctionalComponent } from 'vue'

export const Comp: FunctionalComponent<
  {},
  {},
  {
    default: (scope: { foo: string }) => any
    title: (scope: { bar: number }) => any
  }
> = () => <div />
// #endregion v-slot-dynamic
// ---cut-end---
// @noErrors
import { Comp } from './Comp.tsx'

const slots = defineSlots<{
  default: (scope: { foo: string }) => any
  title: (scope: { bar: number }) => any
}>()

// ---cut-start---
// prettier-ignore
// ---cut-end---
export default () => (
  <Comp>
    <template v-for={(Slot, name) in slots} v-slot:$name$={scope}>
      //                                             ^?
      <Slot {...scope} />
    </template>
  </Comp>
)
</script>
```

<<< ./jsx-directive.md#v-slot-dynamic{tsx} [Comp.tsx]

:::

## 修饰符

修饰符是以 `_` 开头的特殊后缀，表明指令需要以一些特殊的方式被绑定。

```tsx
<form onSubmit_prevent>
  <input v-model_number={value} />
</form>
```

## Volar 配置

```jsonc {3} [tsconfig.json]
{
  "vueCompilerOptions": {
    "plugins": ["vue-macros/volar"],
  },
}
```

---

---
url: /volar/jsx-ref.md
---
# jsxRef <PackageVersion name="@vue-macros/volar" />

<StabilityLevel level="experimental" />

Automatically infer type for `useRef`.

| Features |     Supported      |
| :------: | :----------------: |
|  Volar   | :white_check_mark: |

## Setup Auto Import

::: code-group

```ts [vite.config.ts]
import AutoImport from 'unplugin-auto-import/vite'

export default defineConfig({
  plugins: [
    AutoImport({
      imports: [
        {
          from: 'vue',
          imports: [['shallowRef', 'useRef']],
        },
      ],
    }),
  ],
})
```

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  imports: {
    presets: [
      {
        from: 'vue',
        imports: [['shallowRef', 'useRef']],
      },
    ],
  },
})
```

:::

## Basic Usage

::: code-group

```vue [App.vue] twoslash
<script lang="tsx">
// #region comp
import { defineComponent } from 'vue'

export const Comp = defineComponent({
  setup() {
    return { foo: 1 }
  },
})
// #endregion comp
// ---cut---
import { useRef } from 'vue-macros/runtime'
// Or import { shallowRef as useRef } from 'vue'
// @noErrors
import { Comp } from './Comp.ts'

export default defineComponent(() => {
  const comp = useRef()
  comp.value?.foo
  //           ^?

  return () => (
    <>
      <Comp ref={comp} />
    </>
  )
})
</script>
```

<<< ./jsx-ref.md#comp{ts} [Comp.ts]

:::

## Volar Configuration

```jsonc [tsconfig.json] {3,6}
{
  "vueCompilerOptions": {
    "plugins": ["vue-macros/volar"],
    "vueMacros": {
      "jsxRef": {
        "alias": ["useRef"],
      },
    },
  },
}
```

---

---
url: /zh-CN/volar/jsx-ref.md
---
# jsxRef <PackageVersion name="@vue-macros/volar" />

<StabilityLevel level="experimental" />

自动推断 `useRef` 的类型.

| Features |     Supported      |
| :------: | :----------------: |
|  Volar   | :white_check_mark: |

## 设置自动引入

::: code-group

```ts [vite.config.ts]
import AutoImport from 'unplugin-auto-import/vite'

export default defineConfig({
  plugins: [
    AutoImport({
      imports: [
        {
          from: 'vue',
          imports: [['shallowRef', 'useRef']],
        },
      ],
    }),
  ],
})
```

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  imports: {
    presets: [
      {
        from: 'vue',
        imports: [['shallowRef', 'useRef']],
      },
    ],
  },
})
```

:::

## Basic Usage

::: code-group

```vue [App.vue] twoslash
<script lang="tsx">
// #region comp
import { defineComponent } from 'vue'

export const Comp = defineComponent({
  setup() {
    return { foo: 1 }
  },
})
// #endregion comp
// ---cut---
import { useRef } from 'vue-macros/runtime'
// 或者 import { shallowRef as useRef } from 'vue'
// @noErrors
import { Comp } from './Comp.ts'

export default defineComponent(() => {
  const comp = useRef()
  comp.value?.foo
  //           ^?

  return () => (
    <>
      <Comp ref={comp} />
    </>
  )
})
</script>
```

<<< ./jsx-ref.md#comp{ts} [Comp.ts]

:::

## Volar Configuration

```jsonc [tsconfig.json] {3,6}
{
  "vueCompilerOptions": {
    "plugins": ["vue-macros/volar"],
    "vueMacros": {
      "jsxRef": {
        "alias": ["useRef"],
      },
    },
  },
}
```

---

---
url: /guide/migration-v3.md
---
# Migration from v2 to v3

## Unified Version Management

Initially, we used [`changesets`](https://github.com/changesets/changesets) to
manage the versions of all packages in the monorepo. However, after two years of experimentation,
we decided to adopt a single-version strategy in v3,
where all sub-packages share the same version number, similar to Vue and Babel.
This decision stemmed from our observation that when a sub-package underwent a major change or minor update,
the version number of the main package did not adequately reflect these changes.

For example, when `@vue-macros/define-prop` introduced a breaking change,
how should `unplugin-vue-macros` release a new version?
Should it be a minor or a patch release? When users updated `unplugin-vue-macros`,
they couldn’t easily determine whether the update was due to changes in `@vue-macros/define-prop`.

Therefore, after Anthony proposed [Epoch Semantic Versioning](https://antfu.me/posts/epoch-semver),
we decided to adopt a more frequent major version update strategy,
with all packages sharing the same version number and maintaining a single unified changelog.

## Main Package Rename

We have renamed the main package from `unplugin-vue-macros` to **`vue-macros`**.
After the official release of v3, `unplugin-vue-macros` will be marked as deprecated.

As a result, you will need to update your `package.json` and the import statements for Vue Macros:

```diff
 // package.json
 {
   "devDependencies": {
-    "unplugin-vue-macros": "^2.14.5"
+    "vue-macros": "^3.0.0"
   }
 }
```

```diff
- import { $ref } from 'unplugin-vue-macros/macros'
+ import { $ref } from 'vue-macros/macros'

- import VueMacros from 'unplugin-vue-macros/vite'
+ import VueMacros from 'vue-macros/vite'
```

## Dropping Vue 2 Support

Vue 2 reached its end of life (EOL) at the end of 2023, so we have decided to drop support for Vue 2 in v3.
If you are still using Vue 2, we recommend continuing with v2 or
considering our [paid support plan](https://github.com/vue-macros/vue-macros/issues/373).

## Node.js Compatibility Changes

In v3, we have dropped support for Node.js versions below 20.18.
This means the minimum Node.js version requirement for v3 is `20.18.0`.
Additionally, we have removed CommonJS (CJS) outputs and now only provide ECMAScript modules (ESM).

## Dropping Webpack 4 Support

Since Webpack 4 cannot run in Node.js 18 or later environments,
we have also dropped support for Webpack 4 and Vue CLI 4.
We recommend upgrading to modern build tools like Vite or Rspack.

---

---
url: /features/named-template.md
---
# namedTemplate <PackageVersion name="@vue-macros/named-template" />

<StabilityLevel level="experimental" />

::: warning

Not actively maintained now. Try [createReusableTemplate](https://vueuse.org/core/createReusableTemplate/) instead.

:::

With enabling `namedTemplate`, `<template>` can be referenced like a variable.

Sometimes we need to reverse the order of the very simple components, and don't want to give the features of Vue template up and use JSX/TSX. Then this feature is much helpful.

If you support this feature, you can go to [the discussion](https://github.com/vuejs/core/discussions/6898) and hit like :+1: or comment.

|      Features      |     Supported      |
| :----------------: | :----------------: |
|       Vue 3        | :white_check_mark: |
|      Vue 3.3       |        :x:         |
|       Nuxt 3       |        :x:         |
|       Vue 2        |        :x:         |
| TypeScript / Volar |        :x:         |

## Basic Usage

```vue {5-7,10-12,16-18}
<script setup>
const pager = 'top'
</script>

<template name="pager">
  <span>This is pager</span>
</template>

<template>
  <template v-if="pager === 'top'">
    <template is="pager" />
  </template>

  <span>Here is data table</span>

  <template v-if="pager === 'bottom'">
    <template is="pager" />
  </template>
</template>
```

## Known Usage

- TypeScript / Volar support is not yet completed.

---

---
url: /zh-CN/features/named-template.md
---
# namedTemplate <PackageVersion name="@vue-macros/named-template" />

<StabilityLevel level="experimental" />

::: warning

目前没有积极维护。请试试 [createReusableTemplate](https://vueuse.org/core/createReusableTemplate/)。

:::

通过开启 `namedTemplate` ，`<template>` 可以像变量一样被引用。

有时候我们需要把非常简单的组件颠倒顺序，但又不想放弃 Vue 模板的特性而使用 JSX/TSX。那么这个功能就非常有用了。

如果你支持此功能，欢迎在 [讨论](https://github.com/vuejs/core/discussions/6898) 中点赞 :+1: 或评论。

|        特性        |        支持        |
| :----------------: | :----------------: |
|       Vue 3        | :white_check_mark: |
|      Vue 3.3       |        :x:         |
|       Nuxt 3       |        :x:         |
|       Vue 2        |        :x:         |
| TypeScript / Volar |        :x:         |

## 基本用法

```vue {5-7,10-12,16-18}
<script setup>
const pager = 'top'
</script>

<template name="pager">
  <span>This is pager</span>
</template>

<template>
  <template v-if="pager === 'top'">
    <template is="pager" />
  </template>

  <span>Here is data table</span>

  <template v-if="pager === 'bottom'">
    <template is="pager" />
  </template>
</template>
```

## 已知的问题

- TypeScript / Volar 支持尚未完成。

---

---
url: /features/reactivity-transform.md
---
# Reactivity Transform <PackageVersion name="@vue-macros/reactivity-transform" />

<StabilityLevel level="stable" />

|      Features      |     Supported      |
| :----------------: | :----------------: |
|       Vue 3        | :white_check_mark: |
|       Nuxt 3       | :white_check_mark: |
|       Vue 2        | :white_check_mark: |
| TypeScript / Volar | :white_check_mark: |

## Installation Standalone Version

if you need Reactivity Transform feature only, the standalone version is more appropriate for you.

### Installation

::: code-group

```bash [npm]
npm i -D @vue-macros/reactivity-transform
```

```bash [yarn]
yarn add -D @vue-macros/reactivity-transform
```

```bash [pnpm]
pnpm add -D @vue-macros/reactivity-transform
```

:::

::: code-group

```ts [Vite]
// vite.config.ts
import ReactivityTransform from '@vue-macros/reactivity-transform/vite'

export default defineConfig({
  plugins: [ReactivityTransform()],
})
```

```ts [Rollup]
// rollup.config.js
import ReactivityTransform from '@vue-macros/reactivity-transform/rollup'

export default {
  plugins: [ReactivityTransform()],
}
```

```js [esbuild]
// esbuild.config.js
import { build } from 'esbuild'

build({
  plugins: [require('@vue-macros/reactivity-transform/esbuild')()],
})
```

```js [Webpack]
// webpack.config.js
module.exports = {
  /* ... */
  plugins: [require('@vue-macros/reactivity-transform/webpack')()],
}
```

:::

### TypeScript Support

```json [tsconfig.json]
{
  "compilerOptions": {
    // ...
    "types": ["@vue-macros/reactivity-transform/macros-global" /* ... */]
  }
}
```

## Refs vs. Reactive Variables {#refs-vs-reactive-variables}

Ever since the introduction of the Composition API, one of the primary unresolved questions is the use of refs vs. reactive objects. It's easy to lose reactivity when destructuring reactive objects, while it can be cumbersome to use `.value` everywhere when using refs. Also, `.value` is easy to miss if not using a type system.

Reactivity Transform is a compile-time transform that allows us to write code like this:

```vue twoslash
<script setup>
let count = $ref(0)

console.log(count)

function increment() {
  count++
}
</script>

<template>
  <button @click="increment">{{ count }}</button>
</template>
```

The `$ref()` method here is a **compile-time macro**: it is not an actual method that will be called at runtime. Instead, the Vue compiler uses it as a hint to treat the resulting `count` variable as a **reactive variable.**

Reactive variables can be accessed and re-assigned just like normal variables, but these operations are compiled into refs with `.value`. For example, the `<script>` part of the above component is compiled into:

```js{5,8} twoslash
import { ref } from 'vue'

let count = ref(0)

console.log(count.value)

function increment() {
  count.value++
}
```

Every reactivity API that returns refs will have a `$`-prefixed macro equivalent. These APIs include:

- [`ref`](https://vuejs.org/api/reactivity-core#ref) -> `$ref`
- [`computed`](https://vuejs.org/api/reactivity-core#computed) -> `$computed`
- [`shallowRef`](https://vuejs.org/api/reactivity-advanced#shallowref) -> `$shallowRef`
- [`customRef`](https://vuejs.org/api/reactivity-advanced#customref) -> `$customRef`
- [`toRef`](https://vuejs.org/api/reactivity-utilities#toref) -> `$toRef`

These macros are globally available and do not need to be imported when Reactivity Transform is enabled, but you can optionally import them from `vue-macros/macros` or `@vue-macros/reactivity-transform/macros-global` if you want to be more explicit:

```js twoslash
import { $ref } from 'vue-macros/macros'
// for standalone version:
// import { $ref } from '@vue-macros/reactivity-transform/macros-global'

const count = $ref(0)
```

## Destructuring with `$()` {#destructuring-with}

It is common for a composition function to return an object of refs, and use destructuring to retrieve these refs. For this purpose, reactivity transform provides the **`$()`** macro:

```js twoslash
import { ref } from 'vue'
function useMouse() {
  return {
    x: ref(0),
    y: ref(0),
  }
}
// ---cut---
const { x, y } = $(useMouse())

console.log(x, y)
```

Compiled output:

```js twoslash
import { ref } from 'vue'
function useMouse() {
  return {
    x: ref(0),
    y: ref(0),
  }
}
// ---cut---
const __temp = useMouse(),
  x = toRef(__temp, 'x'),
  y = toRef(__temp, 'y')

console.log(x.value, y.value)
```

Note that if `x` is already a ref, `toRef(__temp, 'x')` will simply return it as-is and no additional ref will be created. If a destructured value is not a ref (e.g. a function), it will still work - the value will be wrapped in a ref so the rest of the code works as expected.

`$()` destructure works on both reactive objects **and** plain objects containing refs.

## Convert Existing Refs to Reactive Variables with `$()` {#convert-existing-refs-to-reactive-variables-with}

In some cases we may have wrapped functions that also return refs. However, the Vue compiler won't be able to know ahead of time that a function is going to return a ref. In such cases, the `$()` macro can also be used to convert any existing refs into reactive variables:

```js twoslash
import { ref } from 'vue'

function myCreateRef() {
  return ref(0)
}

const count = $(myCreateRef())
```

## Reactive Props Destructure {#reactive-props-destructure}

There are two pain points with the current `defineProps()` usage in `<script setup>`:

1. Similar to `.value`, you need to always access props as `props.x` in order to retain reactivity. This means you cannot destructure `defineProps` because the resulting destructured variables are not reactive and will not update.

2. When using the [type-only props declaration](https://vuejs.org/api/sfc-script-setup.html#typescript-only-features), there is no easy way to declare default values for the props. We introduced the `withDefaults()` API for this exact purpose, but it's still clunky to use.

We can address these issues by applying a compile-time transform when `defineProps` is used with destructuring, similar to what we saw earlier with `$()`:

```vue twoslash
<script setup lang="ts">
import { watchEffect } from 'vue'

interface Props {
  msg: string
  count?: number
  foo?: string
}

const {
  msg,
  // default value just works
  count = 1,
  // local aliasing also just works
  // here we are aliasing `props.foo` to `bar`
  foo: bar,
} = defineProps<Props>()

watchEffect(() => {
  // will log whenever the props change
  console.log(msg, count, bar)
})
</script>
```

The above will be compiled into the following runtime declaration equivalent:

```ts twoslash
import { defineComponent, watchEffect } from 'vue'

export default defineComponent({
  props: {
    msg: { type: String, required: true },
    count: { type: Number, default: 1 },
    foo: String,
  },
  setup(props) {
    watchEffect(() => {
      console.log(props.msg, props.count, props.foo)
    })
  },
})
```

## Retaining Reactivity Across Function Boundaries {#retaining-reactivity-across-function-boundaries}

While reactive variables relieve us from having to use `.value` everywhere, it creates an issue of "reactivity loss" when we pass reactive variables across function boundaries. This can happen in two cases:

### Passing into function as argument {#passing-into-function-as-argument}

Given a function that expects a ref as an argument, e.g.:

```ts twoslash
import { watch, type Ref } from 'vue'

function trackChange(x: Ref<number>) {
  watch(x, (x) => {
    console.log('x changed!')
  })
}

const count = $ref(0)
// @errors: 2345
trackChange(count) // doesn't work!
```

The above case will not work as expected because it compiles to:

```ts
const count = ref(0)
trackChange(count.value)
```

Here `count.value` is passed as a number, whereas `trackChange` expects an actual ref. This can be fixed by wrapping `count` with `$$()` before passing it:

```diff
let count = $ref(0)
- trackChange(count)
+ trackChange($$(count))
```

The above compiles to:

```js
import { ref } from 'vue'

const count = ref(0)
trackChange(count)
```

As we can see, `$$()` is a macro that serves as an **escape hint**: reactive variables inside `$$()` will not get `.value` appended.

### Returning inside function scope {#returning-inside-function-scope}

Reactivity can also be lost if reactive variables are used directly in a returned expression:

```ts twoslash
function useMouse() {
  const x = $ref(0)
  const y = $ref(0)

  // listen to mousemove...

  // doesn't work!
  return {
    x,
    y,
  }
}
```

The above return statement compiles to:

```ts
return {
  x: x.value,
  y: y.value,
}
```

In order to retain reactivity, we should be returning the actual refs, not the current value at return time.

Again, we can use `$$()` to fix this. In this case, `$$()` can be used directly on the returned object - any reference to reactive variables inside the `$$()` call will retain the reference to their underlying refs:

```ts twoslash
function useMouse() {
  const x = $ref(0)
  const y = $ref(0)

  // listen to mousemove...

  // fixed
  return $$({
    x,
    y,
  })
}
```

### Using `$$()` on destructured props {#using-on-destructured-props}

`$$()` works on destructured props since they are reactive variables as well. The compiler will convert it with `toRef` for efficiency:

```vue twoslash
<script setup lang="ts">
import type { Ref } from 'vue'
function passAsRef(count: Ref<number>) {
  return count
}
// ---cut---
const { count } = defineProps<{ count: number }>()

passAsRef($$(count))
</script>
```

compiles to:

```ts twoslash
import { defineComponent, toRef, type Ref } from 'vue'
function passAsRef(count: Ref<number>) {
  return count
}
// ---cut---
export default defineComponent({
  props: {
    count: { type: Number, required: true },
  },
  setup(props) {
    const __props_count = toRef(props, 'count')
    passAsRef(__props_count)
  },
})
```

## TypeScript Integration <sup class="vt-badge ts" /> {#typescript-integration}

Vue provides typings for these macros (available globally) and all types will work as expected. There are no incompatibilities with standard TypeScript semantics, so the syntax will work with all existing tooling.

This also means the macros can work in any files where valid JS / TS are allowed - not just inside Vue SFCs.

Since the macros are available globally, their types need to be explicitly referenced (e.g. in a `env.d.ts` file):

```ts [env.d.ts]
/// <reference types="vue-macros/macros-global" />

// or for standalone version:
/// <reference types="@vue-macros/reactivity-transform/macros-global" />
```

When explicitly importing the macros from `vue-macros/macros` or `@vue-macros/reactivity-transform/macros-global`, the type will work without declaring the globals.

---

---
url: /zh-CN/features/reactivity-transform.md
---
# Reactivity Transform <PackageVersion name="@vue-macros/reactivity-transform" />

<StabilityLevel level="stable" />

|        特性        |        支持        |
| :----------------: | :----------------: |
|       Vue 3        | :white_check_mark: |
|       Nuxt 3       | :white_check_mark: |
|       Vue 2        | :white_check_mark: |
| TypeScript / Volar | :white_check_mark: |

## 安装独立版本

如果你只需要 `Reactivity Transform` 功能，独立版本更适合你。

### 安装

::: code-group

```bash [npm]
npm i -D @vue-macros/reactivity-transform
```

```bash [yarn]
yarn add -D @vue-macros/reactivity-transform
```

```bash [pnpm]
pnpm add -D @vue-macros/reactivity-transform
```

:::

::: code-group

```ts [Vite]
// vite.config.ts
import ReactivityTransform from '@vue-macros/reactivity-transform/vite'

export default defineConfig({
  plugins: [ReactivityTransform()],
})
```

```ts [Rollup]
// rollup.config.js
import ReactivityTransform from '@vue-macros/reactivity-transform/rollup'

export default {
  plugins: [ReactivityTransform()],
}
```

```js [esbuild]
// esbuild.config.js
import { build } from 'esbuild'

build({
  plugins: [require('@vue-macros/reactivity-transform/esbuild')()],
})
```

```js [Webpack]
// webpack.config.js
module.exports = {
  /* ... */
  plugins: [require('@vue-macros/reactivity-transform/webpack')()],
}
```

:::

### TypeScript 支持

```json [tsconfig.json]
{
  "compilerOptions": {
    // ...
    "types": ["@vue-macros/reactivity-transform/macros-global" /* ... */]
  }
}
```

## ref vs. 响应式变量 {#refs-vs-reactive-variables}

自从引入组合式 API 的概念以来，一个主要的未解决的问题就是 ref 和响应式对象到底用哪个。响应式对象存在解构丢失响应性的问题，而 ref 需要到处使用 `.value` 则感觉很繁琐，并且在没有类型系统的帮助时很容易漏掉 `.value`。

响应性语法糖是一个编译时的转换步骤，让我们可以像这样书写代码：

```vue twoslash
<script setup>
let count = $ref(0)

console.log(count)

function increment() {
  count++
}
</script>

<template>
  <button @click="increment">{{ count }}</button>
</template>
```

这里的这个 `$ref()` 方法是一个**编译时的宏命令**：它不是一个真实的、在运行时会调用的方法。而是用作 Vue 编译器的标记，表明最终的 `count` 变量需要是一个**响应式变量**。

响应式的变量可以像普通变量那样被访问和重新赋值，但这些操作在编译后都会变为带 `.value` 的 ref。比如上面例子中 `<script>` 部分的代码就被编译成了下面这样：

```js{5,8} twoslash
import { ref } from 'vue'

let count = ref(0)

console.log(count.value)

function increment() {
  count.value++
}
```

每一个会返回 ref 的响应式 API 都有一个相对应的、以 `$` 为前缀的宏函数。包括以下这些 API：

- [`ref`](https://vuejs.org/api/reactivity-core#ref) -> `$ref`
- [`computed`](https://vuejs.org/api/reactivity-core#computed) -> `$computed`
- [`shallowRef`](https://vuejs.org/api/reactivity-advanced#shallowref) -> `$shallowRef`
- [`customRef`](https://vuejs.org/api/reactivity-advanced#customref) -> `$customRef`
- [`toRef`](https://vuejs.org/api/reactivity-utilities#toref) -> `$toRef`

当启用响应性语法糖时，这些宏函数都是全局可用的、无需手动导入。但如果你想让它更明显，你也可以选择从 `vue-macros/macros` 或 `@vue-macros/reactivity-transform/macros-global` 中引入它们：

```js twoslash
import { $ref } from 'vue-macros/macros'
// 适用于独立版本：
// import { $ref } from '@vue-macros/reactivity-transform/macros-global'

const count = $ref(0)
```

## 通过 `$()` 解构 {#destructuring-with}

我们常常会让一个组合函数返回一个含数个 ref 的对象，然后解构得到这些 ref。对于这种场景，响应性语法糖提供了一个 **`$()`** 宏：

```ts twoslash
import { ref } from 'vue'
function useMouse() {
  return {
    x: ref(0),
    y: ref(0),
  }
}
// ---cut---
const { x, y } = $(useMouse())

console.log(x, y)
```

编译输出为：

```js twoslash
import { ref, toRef } from 'vue'
function useMouse() {
  return {
    x: ref(0),
    y: ref(0),
  }
}
// ---cut---
const __temp = useMouse(),
  x = toRef(__temp, 'x'),
  y = toRef(__temp, 'y')

console.log(x.value, y.value)
```

请注意如果 `x` 已经是一个 ref，`toRef(__temp, 'x')` 则会简单地返回它本身，而不会再创建新的 ref。如果一个被解构的值不是 ref (例如是一个函数)，也仍然可以使用，这个值会被包装进一个 ref，因此其他代码都会正常工作。

对 `$()` 的解构在响应式对象**和**包含数个 ref 的对象都可用。

## 用 `$()` 将现存的 ref 转换为响应式对象 {#convert-existing-refs-to-reactive-variables-with}

在某些场景中我们可能已经有了会返回 ref 的函数。然而，Vue 编译器并不能够提前知道该函数会返回一个 ref。那么此时可以使用 `$()` 宏来将现存的 ref 转换为响应式变量。

```js twoslash
import { ref } from 'vue'

function myCreateRef() {
  return ref(0)
}

const count = $(myCreateRef())
```

## 响应式 props 解构 {#reactive-props-destructure}

现在的 `<script setup>` 中对 `defineProps` 宏的使用有两个痛点：

1. 和 `.value` 类似，为了保持响应性，你始终需要以 `props.x` 的方式访问这些 prop。这意味着你不能够解构 `defineProps` 的返回值，因为得到的变量将不是响应式的、也不会更新。

2. 当使用[基于类型的 props 的声明](https://cn.vuejs.org/api/sfc-script-setup.html#typescript-only-features)时，无法很方便地声明这些 prop 的默认值。为此我们提供了 `withDefaults()` 这个 API，但使用起来仍然很笨拙。

当 `defineProps` 与解构一起使用时，我们可以通过应用编译时转换来解决这些问题，类似于我们之前看到的 `$()`：

```vue twoslash
<script setup lang="ts">
import { watchEffect } from 'vue'

interface Props {
  msg: string
  count?: number
  foo?: string
}

const {
  msg,
  // 默认值正常可用
  count = 1,
  // 解构时命别名也可用
  // 这里我们就将 `props.foo` 命别名为 `bar`
  foo: bar,
} = defineProps<Props>()

watchEffect(() => {
  // 会在 props 变化时打印
  console.log(msg, count, bar)
})
</script>
```

上面的代码将被编译成下面这样的运行时声明：

```ts twoslash
import { defineComponent, watchEffect } from 'vue'

export default defineComponent({
  props: {
    msg: { type: String, required: true },
    count: { type: Number, default: 1 },
    foo: String,
  },
  setup(props) {
    watchEffect(() => {
      console.log(props.msg, props.count, props.foo)
    })
  },
})
```

## 保持在函数间传递时的响应性 {#retaining-reactivity-across-function-boundaries}

虽然响应式变量使我们可以不再受 `.value` 的困扰，但它也使得我们在函数间传递响应式变量时可能造成“响应性丢失”的问题。这可能在以下两种场景中出现：

### 以参数形式传入函数 {#passing-into-function-as-argument}

假设有一个期望接收一个 ref 对象为参数的函数：

```ts twoslash
import { watch, type Ref } from 'vue'

function trackChange(x: Ref<number>) {
  watch(x, (x) => {
    console.log('x 改变了！')
  })
}

const count = $ref(0)
// @errors: 2345
trackChange(count) // 无效！
```

上面的例子不会正常工作，因为代码被编译成了这样：

```ts
const count = ref(0)
trackChange(count.value)
```

这里的 `count.value` 是以一个 number 类型值的形式传入，然而 `trackChange` 期望接收的是一个真正的 ref。要解决这个问题，可以在将 `count` 作为参数传入之前，用 `$$()` 包装：

```diff
let count = $ref(0)
- trackChange(count)
+ trackChange($$(count))
```

上面的代码将被编译成：

```js
import { ref } from 'vue'

const count = ref(0)
trackChange(count)
```

我们可以看到，`$$()` 的效果就像是一个**转义标识**：`$$()` 中的响应式变量不会追加上 `.value`。

### 作为函数返回值 {#returning-inside-function-scope}

如果将响应式变量直接放在返回值表达式中会丢失掉响应性：

```ts twoslash
function useMouse() {
  const x = $ref(0)
  const y = $ref(0)

  // 监听 mousemove 事件

  // 不起效！
  return {
    x,
    y,
  }
}
```

上面的语句将被翻译为：

```ts
return {
  x: x.value,
  y: y.value,
}
```

为了保持响应性，我们需要返回的是真正的 ref，而不是返回时 ref 内的值。

我们还是可以使用 `$$()` 来解决这个问题。在这个例子中，`$$()` 可以直接用在要返回的对象上，`$$()` 调用时任何对响应式变量的引用都会保留为对相应 ref 的引用：

```ts twoslash
function useMouse() {
  const x = $ref(0)
  const y = $ref(0)

  // 监听 mousemove 事件

  // 修改后起效
  return $$({
    x,
    y,
  })
}
```

### 在已解构的 props 上使用 `$$()` {#using-on-destructured-props}

`$$()` 也适用于已解构的 props，因为它们也是响应式的变量。编译器会高效地通过 `toRef` 来做转换：

```vue twoslash
<script setup lang="ts">
import type { Ref } from 'vue'
function passAsRef(count: Ref<number>) {
  return count
}
// ---cut---
const { count } = defineProps<{ count: number }>()

passAsRef($$(count))
</script>
```

编译结果为：

```ts twoslash
import { defineComponent, toRef, type Ref } from 'vue'
function passAsRef(count: Ref<number>) {
  return count
}
// ---cut---
export default defineComponent({
  props: {
    count: { type: Number, required: true },
  },
  setup(props) {
    const __props_count = toRef(props, 'count')
    passAsRef(__props_count)
  },
})
```

## TypeScript 集成 <sup class="vt-badge ts" /> {#typescript-integration}

Vue 为这些宏函数都提供了类型声明 (全局可用)，因此类型推导都会符合预期。它与标准的 TypeScript 语义没有不兼容之处，因此它的语法可以与所有现有的工具兼容。

这也意味着这些宏函数在任何 JS / TS 文件中都是合法的，不是仅能在 Vue SFC 中使用。

因为这些宏函数都是全局可用的，它们的类型需要被显式地引用 (例如，在 `env.d.ts` 文件中)：

```ts [env.d.ts]
/// <reference types="vue-macros/macros-global" />

// 或适用于独立版本：
/// <reference types="@vue-macros/reactivity-transform/macros-global" />
```

若你是从 `vue-macros/macros` 或 `@vue-macros/reactivity-transform/macros-global` 中显式引入宏函数时，则不需要像这样全局声明。

---

---
url: /features/script-lang.md
---
# scriptLang <PackageVersion name="@vue-macros/script-lang" />

<StabilityLevel level="experimental" />

Set the default language for `<script>` block.

::: tip
Convert `<script setup>` to `<script setup lang="ts">`.
:::

|   Features   |     Supported      |
| :----------: | :----------------: |
|    Vue 3     | :white_check_mark: |
|    Nuxt 3    | :white_check_mark: |
|    Vue 2     | :white_check_mark: |
| Volar Plugin | :white_check_mark: |

## Options

```ts
interface Options {
  /**
   * @default 'ts'
   */
  defaultLang?: 'ts' | 'tsx' | 'jsx' | string
}
```

## Usage

```vue twoslash
<script setup>
defineProps<{
  foo: string
}>()
</script>
```

## Volar Configuration

```jsonc {3,5-7} [tsconfig.json]
{
  "vueCompilerOptions": {
    "plugins": ["vue-macros/volar"],
    "vueMacros": {
      "scriptLang": {
        "defaultLang": "ts",
      },
    },
  },
}
```

---

---
url: /zh-CN/features/script-lang.md
---
# scriptLang <PackageVersion name="@vue-macros/script-lang" />

<StabilityLevel level="experimental" />

为 `<script>` 块设置默认语言。

::: tip
把 `<script setup>` 转换为 `<script setup lang="ts">`.
:::

|   Features   |     Supported      |
| :----------: | :----------------: |
|    Vue 3     | :white_check_mark: |
|    Nuxt 3    | :white_check_mark: |
|    Vue 2     | :white_check_mark: |
| Volar Plugin | :white_check_mark: |

## Options

```ts
interface Options {
  /**
   * @default 'ts'
   */
  defaultLang?: 'ts' | 'tsx' | 'jsx' | string
}
```

## Usage

```vue twoslash
<script setup>
defineProps<{
  foo: string
}>()
</script>
```

## Volar Configuration

```jsonc {3,5-7} [tsconfig.json]
{
  "vueCompilerOptions": {
    "plugins": ["vue-macros/volar"],
    "vueMacros": {
      "scriptLang": {
        "defaultLang": "ts",
      },
    },
  },
}
```

---

---
url: /volar/script-sfc.md
---
# scriptSFC <PackageVersion name="@vue-macros/volar" />

<StabilityLevel level="experimental" />

Enabled Volar support for `.ts` | `.tsx` files.

|   Features   |     Supported      |
| :----------: | :----------------: |
| Volar Plugin | :white_check_mark: |

## Basic Usage

### With `jsxDirective`

::: code-group

```tsx [App.tsx]
export default ({ foo }: { foo: number }) => (
  <div v-if={foo === 1}>{foo}</div>
  //                     ^ will be inferred as 1
)
```

:::

## Volar Configuration

```jsonc {3,5} [tsconfig.json]
{
  "vueCompilerOptions": {
    "plugins": ["@vue-macros/volar"],
    "vueMacros": {
      "scriptSFC": true,
    },
  },
}
```

---

---
url: /zh-CN/volar/script-sfc.md
---
# scriptSFC <PackageVersion name="@vue-macros/volar" />

<StabilityLevel level="experimental" />

为 `.ts` 和 `.tsx` 文件提供 Volar 支持.

|   Features   |     Supported      |
| :----------: | :----------------: |
| Volar Plugin | :white_check_mark: |

## 基本用法

### 和 `jsxDirective` 一起使用

::: code-group

```tsx [App.tsx]
export default ({ foo }: { foo: number }) => (
  <div v-if={foo === 1}>{foo}</div>
  //                     ^ 将被推断为 1
)
```

:::

## Volar 配置

```jsonc {3,5} [tsconfig.json]
{
  "vueCompilerOptions": {
    "plugins": ["@vue-macros/volar"],
    "vueMacros": {
      "scriptSFC": true,
    },
  },
}
```

---

---
url: /macros/setup-component.md
---
# setupComponent <PackageVersion name="@vue-macros/setup-component" />

<StabilityLevel level="experimental" />

::: tip

`defineRender` cannot be disabled when using `setupComponent`.

Files in `node_modules` will be ignored by default.

:::

With `defineSetupComponent`, `<script setup>` code can be put in **pure JS/TS(X)** without [Vue Language Tools (Volar)](https://github.com/johnsoncodehk/volar) extension.

|  Features  |     Supported      |
| :--------: | :----------------: |
|   Vue 3    | :white_check_mark: |
|   Nuxt 3   |        :x:         |
|   Vue 2    |        :x:         |
| TypeScript |        :x:         |

See also [Vue Vine](https://vue-vine.dev/) - another style for Vue functional component.

## Basic Usage

```tsx twoslash
export const App = defineSetupComponent(() => {
  defineProps<{
    foo: string
  }>()

  defineEmits<{
    (evt: 'change'): void
  }>()

  defineOptions({
    name: 'App',
  })

  // ...
  return <div />
})
```

## Type Annotation

```ts twoslash
export const App: SetupFC = () => {
  defineProps<{
    foo: string
  }>()

  defineEmits<{
    (evt: 'change'): void
  }>()

  defineOptions({
    name: 'App',
  })
}
```

## Known Issues

- TypeScript support is not yet completed.
- The source map does not correspond properly.

---

---
url: /zh-CN/macros/setup-component.md
---
# setupComponent <PackageVersion name="@vue-macros/setup-component" />

<StabilityLevel level="experimental" />

::: tip

如果使用 `setupComponent` 时，不能禁用 `defineRender`。

默认情况下将会忽略 `node_modules` 中的文件。

:::

使用 `defineSetupComponent` 可以将 `<script setup>` 中的代码放在 **纯 JS/TS(X)** 中，而不需要使用 [Vue Language Tools (Volar)](https://github.com/johnsoncodehk/volar) 扩展。

|    特性    |        支持        |
| :--------: | :----------------: |
|   Vue 3    | :white_check_mark: |
|   Nuxt 3   |        :x:         |
|   Vue 2    |        :x:         |
| TypeScript |        :x:         |

另请参见 [Vue Vine](https://vue-vine.dev/) - Vue 函数组件的另一种风格。

## 基本用法

```tsx twoslash
export const App = defineSetupComponent(() => {
  defineProps<{
    foo: string
  }>()

  defineEmits<{
    (evt: 'change'): void
  }>()

  defineOptions({
    name: 'App',
  })

  // ...
  return <div />
})
```

## 类型注解

```ts twoslash
export const App: SetupFC = () => {
  defineProps<{
    foo: string
  }>()

  defineEmits<{
    (evt: 'change'): void
  }>()

  defineOptions({
    name: 'App',
  })
}
```

## 已知的问题

- TypeScript 支持尚未完成。
- Source map 不能正确映射。

---

---
url: /volar/setup-jsdoc.md
---
# setupJsdoc <PackageVersion name="@vue-macros/volar" />

<StabilityLevel level="stable" />

Define the component's JSDoc in the script setup block.

|   Features   |     Supported      |
| :----------: | :----------------: |
| Volar Plugin | :white_check_mark: |

## Basic Usage

````vue twoslash
<script setup lang="tsx">
/**
 * @example
 * ```vue
 * <Comp :foo="1" />
 * ```
 */
const Comp = () => <div />
// ---cut---
// @noErrors
import Comp from './Comp.vue'
//     ^?
</script>

<template>
  <Comp />
</template>
````

### There are two places to define

1. The first line of the script setup block.

````vue
<script setup lang="ts">
/**
 * @example
 * ```vue
 * <Comp :foo="1" />
 * ```
 */

defineProps<{
  foo: number
}>()
</script>
````

2. Above the `export default` expression.

::: tip

This feature depends on `exportRender`, and make sure `exportRender` is not disabled.

:::

````vue
<script setup lang="tsx">
defineProps<{
  foo: number
}>()

/**
 * @example
 * ```vue
 * <Comp :foo="1" />
 * ```
 */
export default <div />
</script>
````

## Volar Configuration

```jsonc {3} [tsconfig.json]
{
  "vueCompilerOptions": {
    "plugins": ["vue-macros/volar"],
  },
}
```

---

---
url: /zh-CN/volar/setup-jsdoc.md
---
# setupJsdoc <PackageVersion name="@vue-macros/volar" />

<StabilityLevel level="stable" />

在 `script setup` 块里定义组件的 `JSDoc`。

|   Features   |     Supported      |
| :----------: | :----------------: |
| Volar Plugin | :white_check_mark: |

## 基本用法

````vue twoslash
<script setup lang="tsx">
/**
 * @example
 * ```vue
 * <Comp :foo="1" />
 * ```
 */
const Comp = () => <div />
// ---cut---
// @noErrors
import Comp from './Comp.vue'
//     ^?
</script>

<template>
  <Comp />
</template>
````

### 有两个地方可以去定义

1. `script setup` 代码块的第一行.

````vue
<script setup lang="ts">
/**
 * @example
 * ```vue
 * <Comp :foo="1" />
 * ```
 */

defineProps<{
  foo: number
}>()
</script>
````

2. 在 `export default` 表达式的上面.

::: tip

这个特性依赖于 `exportRender`，并确保 `exportRender` 没有被禁用。

:::

````vue
<script setup lang="tsx">
defineProps<{
  foo: number
}>()

/**
 * @example
 * ```vue
 * <Comp :foo="1" />
 * ```
 */
export default <div />
</script>
````

## Volar 配置

```jsonc {3} [tsconfig.json]
{
  "vueCompilerOptions": {
    "plugins": ["vue-macros/volar"],
  },
}
```

---

---
url: /macros/setup-sfc.md
---
# setupSFC <PackageVersion name="@vue-macros/setup-sfc" />

<StabilityLevel level="experimental" />

::: tip

If you're using `setupSFC`, then `defineRender` cannot be disabled.

:::

|      Features      |     Supported      |
| :----------------: | :----------------: |
|       Vue 3        | :white_check_mark: |
|       Nuxt 3       | :white_check_mark: |
|       Vue 2        | :white_check_mark: |
| TypeScript / Volar | :white_check_mark: |

## Setup

::: code-group

```ts {7-14} [Vite]
// vite.config.ts
import Vue from '@vitejs/plugin-vue'
import VueMacros from 'vue-macros/vite'

export default defineConfig({
  plugins: [
    VueMacros({
      plugins: {
        vue: Vue({
          include: [/\.vue$/, /\.setup\.[cm]?[jt]sx?$/],
          //                   ⬆️ setupSFC pattern need to be added
        }),
      },
    }),
  ],
})
```

```ts {6-13} [Rollup]
import Vue from 'unplugin-vue/rollup'
import VueMacros from 'vue-macros/rollup'

export default defineConfig({
  plugins: [
    VueMacros({
      plugins: {
        vue: Vue({
          include: [/\.vue$/, /\.setup\.[cm]?[jt]sx?$/],
          //                   ⬆️ setupSFC pattern need to be added
        }),
      },
    }),
  ],
})
```

```[🚧 esbuild]
🚧
```

```[🚧 Webpack]
🚧
```

:::

## Basic Usage

```tsx twoslash
// Foo.setup.tsx
defineProps<{
  foo: string
}>()

defineEmits<{
  (evt: 'change'): void
}>()

export default () => (
  <div>
    <h1>Hello World</h1>
  </div>
)
```

## Volar Configuration

```jsonc {3,5} [tsconfig.json]
{
  "vueCompilerOptions": {
    "plugins": ["vue-macros/volar"],
    "vueMacros": {
      "setupSFC": true,
    },
  },
}
```

---

---
url: /zh-CN/macros/setup-sfc.md
---
# setupSFC <PackageVersion name="@vue-macros/setup-sfc" />

<StabilityLevel level="experimental" />

::: tip

如果你使用的是 `setupSFC`，则不能禁用 `defineRender`。

:::

|        特性        |        支持        |
| :----------------: | :----------------: |
|       Vue 3        | :white_check_mark: |
|       Nuxt 3       | :white_check_mark: |
|       Vue 2        | :white_check_mark: |
| TypeScript / Volar | :white_check_mark: |

## 安装

::: code-group

```ts {7-14} [Vite]
// vite.config.ts
import Vue from '@vitejs/plugin-vue'
import VueMacros from 'vue-macros/vite'

export default defineConfig({
  plugins: [
    VueMacros({
      plugins: {
        vue: Vue({
          include: [/\.vue$/, /\.setup\.[cm]?[jt]sx?$/],
          //                   ⬆️ 需要添加 setup 模式
        }),
      },
    }),
  ],
})
```

```ts {6-13} [Rollup]
import Vue from 'unplugin-vue/rollup'
import VueMacros from 'vue-macros/rollup'

export default defineConfig({
  plugins: [
    VueMacros({
      plugins: {
        vue: Vue({
          include: [/\.vue$/, /\.setup\.[cm]?[jt]sx?$/],
          //                   ⬆️ 需要添加 setup 模式
        }),
      },
    }),
  ],
})
```

```[🚧 esbuild]
🚧
```

```[🚧 Webpack]
🚧
```

:::

## 基本用法

```tsx twoslash
// Foo.setup.tsx
defineProps<{
  foo: string
}>()

defineEmits<{
  (evt: 'change'): void
}>()

export default () => (
  <div>
    <h1>Hello World</h1>
  </div>
)
```

## Volar 配置

```jsonc {3} [tsconfig.json]
{
  "vueCompilerOptions": {
    "plugins": ["vue-macros/volar"],
  },
}
```

---

---
url: /features/short-bind.md
---
# shortBind <PackageVersion name="@vue-macros/short-bind" />

<StabilityLevel level="stable" />

`:value` -> `:value="value"`

Same-name shorthand for binding prop. If the attribute has the same name with the JavaScript value being bound, the syntax can be further shortened to omit the attribute value.

For Vue >= 3.4, this feature will be turned off by default.

|   Features   |     Supported      |
| :----------: | :----------------: |
|    Vue 3     | :white_check_mark: |
|    Nuxt 3    | :white_check_mark: |
|    Vue 2     |        :x:         |
| Volar Plugin | :white_check_mark: |

## Usage

### Basic Usage

```vue twoslash
<script setup>
const value = 'foo'
</script>

<template>
  <input :value />
  <!-- => <input :foo="value" /> -->
</template>
```

### With `shortVmodel`

```vue
<template>
  <Comp ::value />
  <!-- => <Comp ::foo="foo" /> => <Comp v-model:foo="foo" /> -->
  <Comp $foo />
  <!-- => <Comp $foo="foo" /> => <Comp v-model:foo="foo" /> -->
  <Comp *foo />
  <!-- => <Comp *foo="foo" /> => <Comp v-model:foo="foo" /> -->
</template>
```

## Volar Configuration

```jsonc {3} [tsconfig.json]
{
  "vueCompilerOptions": {
    "plugins": ["vue-macros/volar"],
  },
}
```

---

---
url: /zh-CN/features/short-bind.md
---
# shortBind <PackageVersion name="@vue-macros/short-bind" />

<StabilityLevel level="stable" />

`:value` -> `:value="value"`

同名简写绑定 prop 。如果 prop 与要绑定的 JavaScript 值同名，则可以进一步缩短语法以省略 prop 值。

对于 Vue >= 3.4，此功能将默认关闭。

|   Features   |     Supported      |
| :----------: | :----------------: |
|    Vue 3     | :white_check_mark: |
|    Nuxt 3    | :white_check_mark: |
|    Vue 2     |        :x:         |
| Volar Plugin | :white_check_mark: |

## 用法

### 基本用法

```vue twoslash
<script setup>
const value = 'foo'
</script>

<template>
  <input :value />
  <!-- => <input :value="value" /> -->
</template>
```

### 和 `shortVmodel` 一起使用

```vue
<template>
  <Comp ::msg />
  <!-- => <Comp ::foo="foo" /> => <Comp v-model:foo="foo" /> -->
  <Comp $msg />
  <!-- => <Comp $foo="foo" /> => <Comp v-model:foo="foo" /> -->
  <Comp *msg />
  <!-- => <Comp *foo="foo" /> => <Comp v-model:foo="foo" /> -->
</template>
```

## Volar 配置

```jsonc {3} [tsconfig.json]
{
  "vueCompilerOptions": {
    "plugins": ["vue-macros/volar"],
  },
}
```

---

---
url: /macros/short-emits.md
---
# shortEmits <PackageVersion name="@vue-macros/short-emits" />

<StabilityLevel level="stable" />

Simplify the definition of emits.

For Vue >= 3.3, this feature will be turned off by default.

|  Features  |     Supported      |
| :--------: | :----------------: |
|   Vue 3    | :white_check_mark: |
|   Vue 2    | :white_check_mark: |
| TypeScript | :white_check_mark: |

## Basic Usage

```vue twoslash
<script setup lang="ts">
import { defineEmits } from 'vue-macros/macros'

const emits = defineEmits<{
  // tuple
  'update:modelValue': [val: string]
  // function
  update: (val: string) => void
}>()
</script>
```

Using type `ShortEmits` or for short `SE`.

```vue twoslash
<script setup lang="ts">
const emits = defineEmits<
  SE<{
    // tuple
    'update:modelValue': [val: string]
    // function
    update: (val: string) => void
  }>
>()
</script>
```

## Difference with Official Version

- function style of declaration is not supported by official version.

---

---
url: /zh-CN/macros/short-emits.md
---
# shortEmits <PackageVersion name="@vue-macros/short-emits" />

<StabilityLevel level="stable" />

简化 `emits` 的定义。

在 Vue >= 3.3 中，此功能将默认关闭。

|    特性    |        功能        |
| :--------: | :----------------: |
|   Vue 3    | :white_check_mark: |
|   Vue 2    | :white_check_mark: |
| TypeScript | :white_check_mark: |

## 基本用法

```vue twoslash
<script setup lang="ts">
import { defineEmits } from 'vue-macros/macros'

const emits = defineEmits<{
  // 元组
  'update:modelValue': [val: string]
  // 方法
  update: (val: string) => void
}>()
</script>
```

使用 `ShortEmits` 或简写为 `SE`，可以使用元组或方法定义。

```vue twoslash
<script setup lang="ts">
const emits = defineEmits<
  SE<{
    // 元组
    'update:modelValue': [val: string]
    // 方法
    update: (val: string) => void
  }>
>()
</script>
```

## 和官方版本不同的是

- 官方版本不支持函数式的声明风格。

---

---
url: /macros/short-vmodel.md
---
# shortVmodel <PackageVersion name="@vue-macros/short-vmodel" />

<StabilityLevel level="stable" />

A shorthand for `v-model`.

`v-model` -> `::` / `$` / `*`

If you have any questions about this feature, you can comment on [RFC Discussion](https://github.com/vuejs/rfcs/discussions/395).

|   Features   |     Supported      |
| :----------: | :----------------: |
|    Vue 3     | :white_check_mark: |
|    Nuxt 3    | :white_check_mark: |
|    Vue 2     |        :x:         |
| Volar Plugin | :white_check_mark: |

## Options

```ts
interface Options {
  /**
   * @default '$'
   */
  prefix?: '::' | '$' | '*'
}
```

## Usage

### `$` Dollar Sign (Default)

```vue
<template>
  <input $="msg" />
  <!-- => <input v-model="msg" /> -->
  <demo $msg="msg" />
  <!-- => <input v-model:msg="msg" /> -->
</template>
```

### `::` Double Binding

```vue
<template>
  <!-- prettier-ignore -->
  <input ::="msg" />
  <!-- => <input v-model="msg" /> -->
  <demo ::msg="msg" />
  <!-- => <input v-model:msg="msg" /> -->
</template>
```

### `*` Asterisk Sign

```vue
<template>
  <input *="msg" />
  <!-- => <input v-model="msg" /> -->
  <demo *msg="msg" />
  <!-- => <input v-model:msg="msg" /> -->
</template>
```

## Volar Configuration

```jsonc {3,5-7} [tsconfig.json]
{
  "vueCompilerOptions": {
    "plugins": ["vue-macros/volar"],
    "vueMacros": {
      "shortVmodel": {
        "prefix": "$",
      },
    },
  },
}
```

## Known Issues

- Prettier will format `::=` to `:=` (e.g. `<div ::="msg" />` -> `<div :="msg" />`). The comment `<!-- prettier-ignore -->` is required if prefix is `::`.

---

---
url: /zh-CN/macros/short-vmodel.md
---
# shortVmodel <PackageVersion name="@vue-macros/short-vmodel" />

<StabilityLevel level="stable" />

`v-model` 的语法糖。

`v-model` -> `::` / `$` / `*`

如果你对此功能有任何疑问，欢迎在 [RFC](https://github.com/vuejs/rfcs/discussions/395) 中发表评论。

|     特性     |        支持        |
| :----------: | :----------------: |
|    Vue 3     | :white_check_mark: |
|    Nuxt 3    | :white_check_mark: |
|    Vue 2     |        :x:         |
| Volar Plugin | :white_check_mark: |

## 选项

```ts
interface Options {
  /**
   * @default '$'
   */
  prefix?: '::' | '$' | '*'
}
```

## 用法

### `$` 美元符号 (默认)

```vue
<template>
  <input $="msg" />
  <!-- => <input v-model="msg" /> -->
  <demo $msg="msg" />
  <!-- => <input v-model:msg="msg" /> -->
</template>
```

### `::` 双引号

```vue
<template>
  <!-- prettier-ignore -->
  <input ::="msg" />
  <!-- => <input v-model="msg" /> -->
  <demo ::msg="msg" />
  <!-- => <input v-model:msg="msg" /> -->
</template>
```

### `*` 星号

```vue
<template>
  <input *="msg" />
  <!-- => <input v-model="msg" /> -->
  <demo *msg="msg" />
  <!-- => <input v-model:msg="msg" /> -->
</template>
```

## Volar 配置

```jsonc {3,5-7} [tsconfig.json]
{
  "vueCompilerOptions": {
    "plugins": ["vue-macros/volar"],
    "vueMacros": {
      "shortVmodel": {
        "prefix": "$",
      },
    },
  },
}
```

## 已知问题

- Prettier 会将 `::=` 格式化为 `:=`（例如 `<div ::="msg" />` -> `<div :="msg" />`）。如果 prefix 为 `::`，则需要添加注释 `<!-- prettier-ignore -->`

---

---
url: /volar/template-ref.md
---
# templateRef <PackageVersion name="@vue-macros/volar" />

<StabilityLevel level="official" />

Automatically infer type for `templateRef` <small>(from [VueUse](https://vueuse.org/core/templateRef/))</small>
and `useTemplateRef` <small>(Vue 3.5+)</small>.

::: warning

This feature is officially supported since Volar (`vue-tsc`) v2.1.0.
Vue Macros is no longer offering this feature as a plugin.

:::

| Features |     Supported      |
| :------: | :----------------: |
|  Volar   | :white_check_mark: |

## Basic Usage

::: code-group

```vue [App.vue] twoslash
<script setup lang="ts">
// #region comp
import { defineComponent } from 'vue'

export const Comp = defineComponent({
  setup() {
    return { foo: 1 }
  },
})
// #endregion comp
// ---cut---
import { templateRef } from '@vueuse/core'
// @noErrors
import { Comp } from './Comp.ts'

const comp = templateRef('comp')
comp.value?.foo
//           ^?
</script>

<template>
  <Comp ref="comp" />
</template>
```

<<< ./template-ref.md#comp{ts} [Comp.ts]

:::

## Volar Configuration

No configuration required.

---

---
url: /zh-CN/volar/template-ref.md
---
# templateRef <PackageVersion name="@vue-macros/volar" />

<StabilityLevel level="official" />

自动推断 `templateRef` <small>(来自 [VueUse](https://vueuse.org/core/templateRef/))</small> 和 `useTemplateRef` <small>(Vue 3.5+)</small> 的类型。

::: warning

此功能自 Volar (`vue-tsc`) v2.1.0 起已得到官方支持。
Vue Macros 不再提供此功能作为插件。

:::

| 特性  |        支持        |
| :---: | :----------------: |
| Volar | :white_check_mark: |

## Basic Usage

::: code-group

```vue [App.vue] twoslash
<script setup lang="ts">
// #region comp
import { defineComponent } from 'vue'

export const Comp = defineComponent({
  setup() {
    return { foo: 1 }
  },
})
// #endregion comp
// ---cut---
import { templateRef } from '@vueuse/core'
// @noErrors
import { Comp } from './Comp.ts'

const comp = templateRef('comp')
comp.value?.foo
//           ^?
</script>

<template>
  <Comp ref="comp" />
</template>
```

<<< ./template-ref.md#comp{ts} [Comp.ts]

:::

## Volar 配置

无需额外配置

---

---
url: /interactive/index.md
---

<script setup>
import InteractiveWrapper from './InteractiveWrapper.vue'
</script>

<InteractiveWrapper />

---

---
url: /zh-CN/interactive/index.md
---

<script setup>
import InteractiveWrapper from '../../interactive/InteractiveWrapper.vue'
</script>

<InteractiveWrapper />

---

---
url: /macros/index.md
---
# Usage

List of all available macros.

Please make sure `vue-macros` is set up correctly. If you haven't yet, read [Getting Started](../guide/getting-started.md) first.

## Implemented by Vue 3.3

- [defineOptions](./define-options.md)
- [defineSlots](./define-slots.md)
- [shortEmits](./short-emits.md)

## Stable Features

- [defineModels](./define-models.md)
- [defineProps](./define-props.md)
- [definePropsRefs](./define-props-refs.md)
- [defineRender](./define-render.md)
- [shortVmodel](./short-vmodel.md)

## Experimental Features

- [defineProp](./define-prop.md)
- [defineEmit](./define-emit.md)
- [setupComponent](./setup-component.md)
- [setupSFC](./setup-sfc.md)
- [chainCall](./chain-call.md)
- [defineStyleX](./define-stylex.md)

---

---
url: /index.md
---


---

---
url: /zh-CN/index.md
---


---

---
url: /zh-CN/guide/migration-v3.md
---
# 从 v2 迁移到 v3

## 统一版本管理

最初，我们使用 [`changesets`](https://github.com/changesets/changesets) 来管理 monorepo 中所有包的版本
然而，经过两年的实践，我们决定在 v3 中采用单一版本策略，即所有子包共享相同的版本号，类似于 Vue 和 Babel 的做法。
这一决策源于我们发现，当某个子包进行重大变更或次要更新时，主包的版本号未能充分反映这些变化。

例如，当 `@vue-macros/define-prop` 发生重大变更时，`unplugin-vue-macros` 应如何发布新版本？是发布次要版本还是补丁版本？
用户在更新 `unplugin-vue-macros` 时，也无法直观了解这一更新是否源于 `@vue-macros/define-prop` 的变更。

因此，在 Anthony 提出 [Epoch Semantic Versioning](https://antfu.me/posts/epoch-semver) 后，
我们决定采用更频繁的主版本更新策略，所有包共享相同的版本号，并仅维护一个统一的变更日志。

## 主包名称变更

我们将主包名称从 `unplugin-vue-macros` 更改为 **`vue-macros`**。
v3 正式发布后，`unplugin-vue-macros` 将被标记为已弃用。

因此，您需要更新 `package.json` 和导入 Vue Macros 的语句：

```diff
 // package.json
 {
   "devDependencies": {
-    "unplugin-vue-macros": "^2.14.5"
+    "vue-macros": "^3.0.0"
   }
 }
```

```diff
- import { $ref } from 'unplugin-vue-macros/macros'
+ import { $ref } from 'vue-macros/macros'

- import VueMacros from 'unplugin-vue-macros/vite'
+ import VueMacros from 'vue-macros/vite'
```

## 移除 Vue 2 支持

Vue 2 已于 2023 年底进入终止支持阶段（EOL），因此我们决定在 v3 中移除对 Vue 2 的支持。
如果您仍在使用 Vue 2，建议您继续使用 v2 版本，或考虑我们的[付费支持计划](https://github.com/vue-macros/vue-macros/issues/373)。

## Node.js 兼容性调整

在 v3 中，我们移除了对 Node.js 20.18 以下版本的支持。这意味着 v3 的最低 Node.js 版本要求为 `20.18.0`。
同时，我们移除了 CommonJS（CJS）产物，仅提供 ECMAScript 模块（ESM）。

## 移除 Webpack 4 支持

由于 Webpack 4 无法在 Node.js 18 及以上环境中运行，我们移除了对 Webpack 4 和 Vue CLI 4 的支持。
建议您升级至 Vite 或 Rspack 等现代构建工具。

---

---
url: /zh-CN/guide/getting-started.md
---
<script setup>
import { version } from 'vue-tsc/package.json'
</script>

# 入门指南

Vue Macros 是一个实现 Vue 非官方提案和想法的库，探索并扩展了其功能和语法。

在继续之前，我们假设你已经熟悉 Vue 的基本用法。

## 要求

- Node.js `>= v20.18.0`
- Vue `>= v2.7` 或 Vue `>= v3.0`
  - 某些功能需要 Vue `>= v3.2.25`
- VSCode 扩展 [Vue - Official](https://marketplace.visualstudio.com/items?itemName=Vue.volar) 和 `vue-tsc` 为 <code>v{{ version }}</code>
  - Vue Macros 会持续尽快适配最新版本，旧版本可能不受支持

::: warning
不支持 WebStorm。
:::

## 创建 Vue Macros 项目

### 安装

::: code-group

```bash [npm]
npm i -g @vue-macros/cli
```

```bash [yarn]
yarn global add @vue-macros/cli
```

```bash [pnpm]
pnpm add -g @vue-macros/cli
```

:::

此命令将安装 [@vue-macros/cli](https://github.com/vue-macros/vue-macros-cli)，这是官方的 Vue Macros 脚手架工具。

### 初始化

::: code-group

```bash [npm]
npm create vite@latest my-vue-macros -- --template vue-ts
cd my-vue-macros
vue-macros init
```

```bash [yarn]
yarn create vite my-vue-macros --template vue-ts
cd my-vue-macros
vue-macros init
```

```bash [pnpm]
pnpm create vite my-vue-macros --template vue-ts
cd my-vue-macros
vue-macros init
```

你将会看到一些可选的实验性功能提示。

:::

## 模板

- [Vite](https://github.com/vue-macros/vite)
- [Nuxt](https://github.com/vue-macros/nuxt)
- [Rsbuild](https://github.com/vue-macros/vue3-rsbuild)

🌟 欢迎更多模板！

## Nuxt 集成

如果你使用 [Nuxt](https://nuxt.com/)，请阅读 [Nuxt 集成](./nuxt-integration.md)。

## 构建工具集成

如果你使用 [Vite](https://vitejs.dev/)、[Rollup](https://rollupjs.org/)、[esbuild](https://esbuild.github.io/)、[Webpack](https://webpack.js.org/)、或 [Rspack](https://www.rspack.dev/)，请阅读 [构建工具集成](./bundler-integration.md)。

---

---
url: /zh-CN/guide/bundler-integration.md
---
# 构建工具集成 <PackageVersion name="vue-macros" />

## 安装

::: tip

完全支持 Vite 和 Rollup，其他构建工具支持有限。

:::

::: code-group

```bash [npm]
npm i -D vue-macros
```

```bash [yarn]
yarn add -D vue-macros
```

```bash [pnpm]
pnpm add -D vue-macros
```

:::

::: code-group

```ts [Vite]
// vite.config.ts
import Vue from '@vitejs/plugin-vue'
import VueMacros from 'vue-macros/vite'
// import VueJsx from '@vitejs/plugin-vue-jsx'
// import VueRouter from 'unplugin-vue-router/vite'

export default defineConfig({
  plugins: [
    VueMacros({
      plugins: {
        vue: Vue(),
        // vueJsx: VueJsx(), // 如有需要
        // vueRouter: VueRouter({ // 如有需要
        //   extensions: ['.vue', '.setup.tsx']
        // })
      },
      // 覆盖插件选项
    }),
  ],
})
```

```ts [Rollup]
import Vue from 'unplugin-vue/rollup'
// rollup.config.js
import VueMacros from 'vue-macros/rollup'
// import VueRouter from 'unplugin-vue-router/rollup'

export default {
  plugins: [
    VueMacros({
      plugins: {
        vue: Vue(),
        // vueJsx: VueJsx(), // 如有需要
        // vueRouter: VueRouter({ // 如有需要
        //   extensions: ['.vue', '.setup.tsx']
        // })
      },
      // 覆盖插件选项
    }),
  ],
}
```

```js [esbuild]
// esbuild.config.js
import { build } from 'esbuild'
// import VueRouter from 'unplugin-vue-router/esbuild'

build({
  plugins: [
    require('vue-macros/esbuild')({
      plugins: {
        vue: require('unplugin-vue/esbuild')(),
        // vueJsx: VueJsx(), // 如有需要
        // vueRouter: VueRouter({ // 如有需要
        //   extensions: ['.vue', '.setup.tsx']
        // })
      },
      // 覆盖插件选项
    }),
  ],
})
```

```js [Webpack]
// webpack.config.js
module.exports = {
  /* ... */
  plugins: [
    require('vue-macros/webpack')({
      // 覆盖插件选项
    }),
  ],
}
```

```js [Rspack]
// rspack.config.js
module.exports = {
  /* ... */
  plugins: [
    require('vue-macros/rspack')({
      // 覆盖插件选项
    }),
  ],
}
```

```js [Rsbuild]
// rsbuild.config.js
module.exports = {
  // ...
  tools: {
    rspack: {
      plugins: [
        require('vue-macros/rspack')({
          // 覆盖插件选项
        }),
      ],
    },
  },
}
```

```js [Vue CLI]
// vue.config.js
const { defineConfig } = require('@vue/cli-service')
const VueMacros = require('vue-macros/webpack')

module.exports = defineConfig({
  // ...
  // ⚠️ 重要
  parallel: false,
  configureWebpack: {
    plugins: [
      VueMacros({
        // 覆盖插件选项
      }),
    ],
  },
})
```

:::

## 配置

详情请参阅 [配置](./configurations.md)。

```ts twoslash [vue-macros.config.ts]
import { defineConfig } from 'vue-macros'
export default defineConfig({
  // 选项
})
```

## TypeScript 支持

```json {0}
// tsconfig.json
{
  "compilerOptions": {
    // ...
    "types": ["vue-macros/macros-global" /* ... */]
  }
}
```

## Volar 支持

详细配置请参阅具体宏的描述。

```jsonc [tsconfig.json]
{
  "vueCompilerOptions": {
    "plugins": ["vue-macros/volar"],
  },
}
```

### 作用域插件

`exportExpose`、`exportProps` 和 `exportRender` 插件不能同时使用，除非提供作用域。

```ts twoslash [vue-macros.config.ts]
import { defineConfig } from 'vue-macros'
export default defineConfig({
  exportExpose: {
    include: ['**/export-expose/**'],
  },
  exportProps: {
    include: ['**/export-props/**'],
  },
  exportRender: {
    include: ['**/export-render/**'],
  },
})
```

---

:tada: 恭喜！你已成功设置 Vue Macros。

想了解更多关于宏的信息，请访问 [所有宏](/macros/) :laughing:.

---

---
url: /zh-CN/macros/index.md
---
# 用法

以下是所有可用宏的列表。

在开始之前，请确保 `vue-macros` 设置正确。如果你还没有设置，请先阅读 [入门](../guide/getting-started.md)

## 被 Vue 3.3 官方支持

- [defineOptions](./define-options.md)
- [defineSlots](./define-slots.md)
- [shortEmits](./short-emits.md)

## 稳定功能

- [defineModels](./define-models.md)
- [defineProps](./define-props.md)
- [definePropsRefs](./define-props-refs.md)
- [defineRender](./define-render.md)
- [shortVmodel](./short-vmodel.md)

## 实验性功能

- [defineProp](./define-prop.md)
- [defineEmit](./define-emit.md)
- [setupComponent](./setup-component.md)
- [setupSFC](./setup-sfc.md)
- [chainCall](./chain-call.md)
- [defineStyleX](./define-stylex.md)

---

---
url: /zh-CN/guide/configurations.md
---
# 配置

## 插件选项

以下功能除外，默认情况下将启用所有功能。

#### 默认关闭

- `exportExpose`
- `exportProps`
- `exportRender`
- `setupSFC`
- `booleanProp`
- `shortBind`

#### Vue >= 3.3 默认关闭

- `defineOptions`
- `defineSlots`
- `hoistStatic`
- `shortEmits`

你可以通过将选项设置为 `true` 来重新启用它们。

```ts twoslash [vue-macros.config.ts(js|ts|json)]
// vue-macros.config.[js,ts,json]

import { defineConfig } from 'vue-macros'
export default defineConfig({
  root: '/your-project-path',

  /**
   * Vue 版本，2, 3, 3.3 等。
   *
   * 可选，自动检测版本
   */
  version: 3,

  /** 默认 true  */
  defineModels: {
    // ...
  },

  // 开启功能
  defineOptions: true,

  // 关闭功能
  hoistStatic: false,

  // ...更多功能
})
```

有关每个功能的配置选项，请参考对应的页面。
